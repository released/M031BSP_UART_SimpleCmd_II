; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\clk.crf ..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;31       */
;;;32     void CLK_DisableCKO(void)
000000  4803              LDR      r0,|L1.16|
;;;33     {
;;;34         /* Disable CKO clock source */
;;;35         CLK->APBCLK0 &= (~CLK_APBCLK0_CLKOCKEN_Msk);
000002  6880              LDR      r0,[r0,#8]
000004  2140              MOVS     r1,#0x40
000006  4388              BICS     r0,r0,r1
000008  4901              LDR      r1,|L1.16|
00000a  6088              STR      r0,[r1,#8]
;;;36     }
00000c  4770              BX       lr
;;;37     
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x40000200

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;587      */
;;;588    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  b50e              PUSH     {r1-r3,lr}
;;;589    {
;;;590        uint32_t u32ClkTbl[3] = {0x0, 0x4, 0x8};    /* AHBCLK/APBCLK offset on MODULE index, 0x0:AHBCLK, 0x1:APBCLK0, 0x2:APBCLK1 */
000002  4b0d              LDR      r3,|L2.56|
000004  681a              LDR      r2,[r3,#0]  ; <Data4>
000006  6859              LDR      r1,[r3,#4]  ; <Data4>
000008  689b              LDR      r3,[r3,#8]  ; <Data4>
00000a  9302              STR      r3,[sp,#8]
00000c  9200              STR      r2,[sp,#0]
00000e  9101              STR      r1,[sp,#4]
;;;591    
;;;592        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (u32ClkTbl[MODULE_APBCLK(u32ModuleIdx)]))  &= ~(1 << MODULE_IP_EN_Pos(u32ModuleIdx));
000010  0f81              LSRS     r1,r0,#30
000012  0089              LSLS     r1,r1,#2
000014  466a              MOV      r2,sp
000016  5851              LDR      r1,[r2,r1]
000018  4a08              LDR      r2,|L2.60|
00001a  1889              ADDS     r1,r1,r2
00001c  6849              LDR      r1,[r1,#4]
00001e  06c3              LSLS     r3,r0,#27
000020  0edb              LSRS     r3,r3,#27
000022  2201              MOVS     r2,#1
000024  409a              LSLS     r2,r2,r3
000026  4391              BICS     r1,r1,r2
000028  0f82              LSRS     r2,r0,#30
00002a  0092              LSLS     r2,r2,#2
00002c  466b              MOV      r3,sp
00002e  589a              LDR      r2,[r3,r2]
000030  4b02              LDR      r3,|L2.60|
000032  18d2              ADDS     r2,r2,r3
000034  6051              STR      r1,[r2,#4]
;;;593    }
000036  bd0e              POP      {r1-r3,pc}
;;;594    
                          ENDP

                  |L2.56|
                          DCD      ||.constdata||+0x2c
                  |L2.60|
                          DCD      0x40000200

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=2

                  CLK_DisablePLL PROC
;;;742      */
;;;743    void CLK_DisablePLL(void)
000000  b500              PUSH     {lr}
;;;744    {
;;;745        /* Switch HCLK to HIRC before disable PLL if current HCLK is PLL */
;;;746        if ((CLK->CLKSEL0 & CLK_CLKSEL0_HCLKSEL_Msk) == CLK_CLKSEL0_HCLKSEL_PLL)
000002  4810              LDR      r0,|L3.68|
000004  6900              LDR      r0,[r0,#0x10]
000006  0740              LSLS     r0,r0,#29
000008  0f40              LSRS     r0,r0,#29
00000a  2802              CMP      r0,#2
00000c  d10f              BNE      |L3.46|
;;;747        {
;;;748            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00000e  480d              LDR      r0,|L3.68|
000010  6800              LDR      r0,[r0,#0]
000012  2104              MOVS     r1,#4
000014  4308              ORRS     r0,r0,r1
000016  490b              LDR      r1,|L3.68|
000018  6008              STR      r0,[r1,#0]
;;;749            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       CLK_WaitClockReady
;;;750            CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
000020  4808              LDR      r0,|L3.68|
000022  6900              LDR      r0,[r0,#0x10]
000024  08c0              LSRS     r0,r0,#3
000026  00c0              LSLS     r0,r0,#3
000028  1dc0              ADDS     r0,r0,#7
00002a  4906              LDR      r1,|L3.68|
00002c  6108              STR      r0,[r1,#0x10]
                  |L3.46|
;;;751        }
;;;752    
;;;753        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
00002e  4805              LDR      r0,|L3.68|
000030  3040              ADDS     r0,r0,#0x40
000032  6800              LDR      r0,[r0,#0]
000034  2101              MOVS     r1,#1
000036  0409              LSLS     r1,r1,#16
000038  4308              ORRS     r0,r0,r1
00003a  4902              LDR      r1,|L3.68|
00003c  3140              ADDS     r1,r1,#0x40
00003e  6008              STR      r0,[r1,#0]
;;;754    }
000040  bd00              POP      {pc}
;;;755    
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      0x40000200

                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_DisableSysTick PROC
;;;821      */
;;;822    void CLK_DisableSysTick(void)
000000  2000              MOVS     r0,#0
;;;823    {
;;;824        /* Set System Tick counter disabled */
;;;825        SysTick->CTRL = 0;
000002  4901              LDR      r1,|L4.8|
000004  6108              STR      r0,[r1,#0x10]
;;;826    }
000006  4770              BX       lr
;;;827    
                          ENDP

                  |L4.8|
                          DCD      0xe000e000

                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_DisableXtalRC PROC
;;;495      */
;;;496    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L5.12|
;;;497    {
;;;498        CLK->PWRCTL &= ~u32ClkMask;
000002  6809              LDR      r1,[r1,#0]
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L5.12|
000008  6011              STR      r1,[r2,#0]
;;;499    }
00000a  4770              BX       lr
;;;500    
                          ENDP

                  |L5.12|
                          DCD      0x40000200

                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;58       */
;;;59     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  b510              PUSH     {r4,lr}
;;;60     {
;;;61         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;62         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | u32ClkDiv | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
000002  2310              MOVS     r3,#0x10
000004  430b              ORRS     r3,r3,r1
000006  0154              LSLS     r4,r2,#5
000008  4323              ORRS     r3,r3,r4
00000a  4c09              LDR      r4,|L6.48|
00000c  6223              STR      r3,[r4,#0x20]
;;;63     
;;;64         /* Enable CKO clock source */
;;;65         CLK->APBCLK0 |= CLK_APBCLK0_CLKOCKEN_Msk;
00000e  4b08              LDR      r3,|L6.48|
000010  3b40              SUBS     r3,r3,#0x40
000012  689b              LDR      r3,[r3,#8]
000014  2440              MOVS     r4,#0x40
000016  4323              ORRS     r3,r3,r4
000018  4c05              LDR      r4,|L6.48|
00001a  3c40              SUBS     r4,r4,#0x40
00001c  60a3              STR      r3,[r4,#8]
;;;66     
;;;67         /* Select CKO clock source */
;;;68         CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_CLKOSEL_Msk)) | (u32ClkSrc);
00001e  4623              MOV      r3,r4
000020  695b              LDR      r3,[r3,#0x14]
000022  2470              MOVS     r4,#0x70
000024  43a3              BICS     r3,r3,r4
000026  4303              ORRS     r3,r3,r0
000028  4c01              LDR      r4,|L6.48|
00002a  3c40              SUBS     r4,r4,#0x40
00002c  6163              STR      r3,[r4,#0x14]
;;;69     }
00002e  bd10              POP      {r4,pc}
;;;70     
                          ENDP

                  |L6.48|
                          DCD      0x40000240

                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;540      */
;;;541    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  b50e              PUSH     {r1-r3,lr}
;;;542    {
;;;543        uint32_t u32ClkTbl[3] = {0x0, 0x4, 0x8};    /* AHBCLK/APBCLK offset on MODULE index, 0x0:AHBCLK, 0x1:APBCLK0, 0x2:APBCLK1 */
000002  4b0d              LDR      r3,|L7.56|
000004  681a              LDR      r2,[r3,#0]  ; <Data3>
000006  6859              LDR      r1,[r3,#4]  ; <Data3>
000008  689b              LDR      r3,[r3,#8]  ; <Data3>
00000a  9302              STR      r3,[sp,#8]
00000c  9200              STR      r2,[sp,#0]
00000e  9101              STR      r1,[sp,#4]
;;;544    
;;;545        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (u32ClkTbl[MODULE_APBCLK(u32ModuleIdx)]))  |= 1 << MODULE_IP_EN_Pos(u32ModuleIdx);
000010  0f81              LSRS     r1,r0,#30
000012  0089              LSLS     r1,r1,#2
000014  466a              MOV      r2,sp
000016  5851              LDR      r1,[r2,r1]
000018  4a08              LDR      r2,|L7.60|
00001a  1889              ADDS     r1,r1,r2
00001c  6849              LDR      r1,[r1,#4]
00001e  06c3              LSLS     r3,r0,#27
000020  0edb              LSRS     r3,r3,#27
000022  2201              MOVS     r2,#1
000024  409a              LSLS     r2,r2,r3
000026  4311              ORRS     r1,r1,r2
000028  0f82              LSRS     r2,r0,#30
00002a  0092              LSLS     r2,r2,#2
00002c  466b              MOV      r3,sp
00002e  589a              LDR      r2,[r3,r2]
000030  4b02              LDR      r3,|L7.60|
000032  18d2              ADDS     r2,r2,r3
000034  6051              STR      r1,[r2,#4]
;;;546    }
000036  bd0e              POP      {r1-r3,pc}
;;;547    
                          ENDP

                  |L7.56|
                          DCD      ||.constdata||+0x20
                  |L7.60|
                          DCD      0x40000200

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;604      */
;;;605    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;606    {
000002  b08b              SUB      sp,sp,#0x2c
000004  460c              MOV      r4,r1
;;;607        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC, u32Outdiv;
;;;608        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR;
;;;609        uint32_t u32PLL_UpperLimit;
;;;610    
;;;611        /* Disable PLL first to avoid unstable when setting PLL */
;;;612        CLK_DisablePLL();
000006  f7fffffe          BL       CLK_DisablePLL
;;;613    
;;;614        /* PLL source clock is from HXT */
;;;615        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
00000a  980b              LDR      r0,[sp,#0x2c]
00000c  2800              CMP      r0,#0
00000e  d10e              BNE      |L8.46|
;;;616        {
;;;617            /* Enable HXT clock */
;;;618            CLK->PWRCTL |= CLK_PWRCTL_HXTEN_Msk;
000010  4858              LDR      r0,|L8.372|
000012  6800              LDR      r0,[r0,#0]
000014  2101              MOVS     r1,#1
000016  4308              ORRS     r0,r0,r1
000018  4956              LDR      r1,|L8.372|
00001a  6008              STR      r0,[r1,#0]
;;;619    
;;;620            /* Wait for HXT clock ready */
;;;621            CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;622    
;;;623            /* Select PLL source clock from HXT */
;;;624            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
000022  2000              MOVS     r0,#0
000024  9007              STR      r0,[sp,#0x1c]
;;;625            u32PllSrcClk = __HXT;
000026  4854              LDR      r0,|L8.376|
000028  900a              STR      r0,[sp,#0x28]
;;;626    
;;;627            /* u32NR start from 2 since NR = INDIV + 2 */
;;;628            u32NR = 2;
00002a  2502              MOVS     r5,#2
00002c  e00e              B        |L8.76|
                  |L8.46|
;;;629        }
;;;630    
;;;631        /* PLL source clock is from HIRC/4 */
;;;632        else
;;;633        {
;;;634            /* Enable HIRC clock */
;;;635            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00002e  4851              LDR      r0,|L8.372|
000030  6800              LDR      r0,[r0,#0]
000032  2104              MOVS     r1,#4
000034  4308              ORRS     r0,r0,r1
000036  494f              LDR      r1,|L8.372|
000038  6008              STR      r0,[r1,#0]
;;;636    
;;;637            /* Wait for HIRC clock ready */
;;;638            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00003a  2010              MOVS     r0,#0x10
00003c  f7fffffe          BL       CLK_WaitClockReady
;;;639    
;;;640            /* Select PLL source clock from HIRC */
;;;641            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC_DIV4;
000040  2001              MOVS     r0,#1
000042  04c0              LSLS     r0,r0,#19
000044  9007              STR      r0,[sp,#0x1c]
;;;642            u32PllSrcClk = __HIRC >> 2;
000046  484d              LDR      r0,|L8.380|
000048  900a              STR      r0,[sp,#0x28]
;;;643    
;;;644            /* u32NR start from 2 since NR = INDIV + 2 */
;;;645            u32NR = 2;
00004a  2502              MOVS     r5,#2
                  |L8.76|
;;;646        }
;;;647    
;;;648        /* Select "NO" according to request frequency */
;;;649        /* Constraint: PLL output frequency must <= 96MHz */
;;;650        /*             PLL output frequency must > 50.14MHz to meet all constraints */
;;;651        if ((GET_CHIP_SERIES_NUM == CHIP_SERIES_NUM_G) || (GET_CHIP_SERIES_NUM == CHIP_SERIES_NUM_I))
00004c  2001              MOVS     r0,#1
00004e  0780              LSLS     r0,r0,#30
000050  6800              LDR      r0,[r0,#0]
000052  210f              MOVS     r1,#0xf
000054  0209              LSLS     r1,r1,#8
000056  4008              ANDS     r0,r0,r1
000058  0a00              LSRS     r0,r0,#8
00005a  2806              CMP      r0,#6
00005c  d006              BEQ      |L8.108|
00005e  2001              MOVS     r0,#1
000060  0780              LSLS     r0,r0,#30
000062  6800              LDR      r0,[r0,#0]
000064  4008              ANDS     r0,r0,r1
000066  0a00              LSRS     r0,r0,#8
000068  2801              CMP      r0,#1
00006a  d102              BNE      |L8.114|
                  |L8.108|
;;;652            u32PLL_UpperLimit = FREQ_144MHZ;
00006c  4844              LDR      r0,|L8.384|
00006e  9001              STR      r0,[sp,#4]
000070  e001              B        |L8.118|
                  |L8.114|
;;;653        else
;;;654            u32PLL_UpperLimit = FREQ_96MHZ;
000072  4844              LDR      r0,|L8.388|
000074  9001              STR      r0,[sp,#4]
                  |L8.118|
;;;655    
;;;656        if((u32PllFreq <= u32PLL_UpperLimit) && (u32PllFreq >= FREQ_51MHZ))
000076  9801              LDR      r0,[sp,#4]
000078  4284              CMP      r4,r0
00007a  d810              BHI      |L8.158|
00007c  4842              LDR      r0,|L8.392|
00007e  4284              CMP      r4,r0
000080  d30d              BCC      |L8.158|
;;;657        {
;;;658            if (u32PllFreq <= FREQ_96MHZ)
000082  4840              LDR      r0,|L8.388|
000084  4284              CMP      r4,r0
000086  d805              BHI      |L8.148|
;;;659            {
;;;660                u32NO = 4;
000088  2004              MOVS     r0,#4
00008a  9008              STR      r0,[sp,#0x20]
;;;661                u32Outdiv = 3;
00008c  2003              MOVS     r0,#3
00008e  9006              STR      r0,[sp,#0x18]
;;;662                u32PllFreq = u32PllFreq << 2;   /* u32PllFreq = (FIN * NF / NR) now */
000090  00a4              LSLS     r4,r4,#2
000092  e005              B        |L8.160|
                  |L8.148|
;;;663            }
;;;664            else
;;;665            {
;;;666                u32NO = 2;
000094  2002              MOVS     r0,#2
000096  9008              STR      r0,[sp,#0x20]
;;;667                u32Outdiv = 2;
000098  9006              STR      r0,[sp,#0x18]
;;;668                u32PllFreq = u32PllFreq << 1;   /* u32PllFreq = (FIN * NF / NR) now */
00009a  0064              LSLS     r4,r4,#1
00009c  e000              B        |L8.160|
                  |L8.158|
;;;669            }
;;;670        }
;;;671        else
;;;672        {
;;;673            /* Wrong frequency request. Just return default setting. */
;;;674            goto lexit;
00009e  e057              B        |L8.336|
                  |L8.160|
;;;675        }
;;;676    
;;;677        /* Find best solution */
;;;678        u32Min = (uint32_t) 0xFFFFFFFF; /* initial u32Min to max value of uint32_t */
0000a0  2000              MOVS     r0,#0
0000a2  43c0              MVNS     r0,r0
0000a4  9004              STR      r0,[sp,#0x10]
;;;679        u32MinNR = 0;
0000a6  2000              MOVS     r0,#0
0000a8  9002              STR      r0,[sp,#8]
;;;680        u32MinNF = 0;
0000aa  9003              STR      r0,[sp,#0xc]
;;;681        for(; u32NR <= 33; u32NR++) /* max NR = 33 since NR = INDIV + 2 and INDIV = 0 ~ 31 */
0000ac  e032              B        |L8.276|
                  |L8.174|
;;;682        {
;;;683            u32Tmp = u32PllSrcClk / u32NR;
0000ae  4629              MOV      r1,r5
0000b0  980a              LDR      r0,[sp,#0x28]
0000b2  f7fffffe          BL       __aeabi_uidivmod
0000b6  4607              MOV      r7,r0
;;;684            /* Constraint 2: 800KHz < (FIN / (2*NR)) < 8MHz */
;;;685            if((u32Tmp > 1600000) && (u32Tmp < 16000000))
0000b8  4934              LDR      r1,|L8.396|
0000ba  428f              CMP      r7,r1
0000bc  d929              BLS      |L8.274|
0000be  4834              LDR      r0,|L8.400|
0000c0  4287              CMP      r7,r0
0000c2  d226              BCS      |L8.274|
;;;686            {
;;;687                for(u32NF = 2; u32NF <= 513; u32NF++) /* NF = 2~513 since NF = FBDIV + 2 and FBDIV = 0 ~ 511 */
0000c4  2002              MOVS     r0,#2
0000c6  9009              STR      r0,[sp,#0x24]
0000c8  e01e              B        |L8.264|
                  |L8.202|
;;;688                {
;;;689                    u32Tmp2 = u32Tmp * u32NF;
0000ca  463e              MOV      r6,r7
0000cc  9809              LDR      r0,[sp,#0x24]
0000ce  4346              MULS     r6,r0,r6
;;;690                    /* Constraint 3: 200MHz < (FIN * NF / NR) < 500MHz */
;;;691                    if((u32Tmp2 >= 200000000) && (u32Tmp2 < 500000000))
0000d0  4830              LDR      r0,|L8.404|
0000d2  4286              CMP      r6,r0
0000d4  d315              BCC      |L8.258|
0000d6  4830              LDR      r0,|L8.408|
0000d8  4286              CMP      r6,r0
0000da  d212              BCS      |L8.258|
;;;692                    {
;;;693                        u32Tmp3 = (u32Tmp2 > u32PllFreq) ? u32Tmp2 - u32PllFreq : u32PllFreq - u32Tmp2;
0000dc  42a6              CMP      r6,r4
0000de  d901              BLS      |L8.228|
0000e0  1b30              SUBS     r0,r6,r4
0000e2  e000              B        |L8.230|
                  |L8.228|
0000e4  1ba0              SUBS     r0,r4,r6
                  |L8.230|
0000e6  9005              STR      r0,[sp,#0x14]
;;;694                        if(u32Tmp3 < u32Min)
0000e8  9904              LDR      r1,[sp,#0x10]
0000ea  9805              LDR      r0,[sp,#0x14]
0000ec  4288              CMP      r0,r1
0000ee  d208              BCS      |L8.258|
;;;695                        {
;;;696                            u32Min = u32Tmp3;
0000f0  9805              LDR      r0,[sp,#0x14]
0000f2  9004              STR      r0,[sp,#0x10]
;;;697                            u32MinNR = u32NR;
0000f4  9502              STR      r5,[sp,#8]
;;;698                            u32MinNF = u32NF;
0000f6  9809              LDR      r0,[sp,#0x24]
0000f8  9003              STR      r0,[sp,#0xc]
;;;699    
;;;700                            /* Break when get good results */
;;;701                            if(u32Min == 0)
0000fa  9804              LDR      r0,[sp,#0x10]
0000fc  2800              CMP      r0,#0
0000fe  d100              BNE      |L8.258|
;;;702                                break;
000100  e006              B        |L8.272|
                  |L8.258|
000102  9809              LDR      r0,[sp,#0x24]         ;687
000104  1c40              ADDS     r0,r0,#1              ;687
000106  9009              STR      r0,[sp,#0x24]         ;687
                  |L8.264|
000108  4924              LDR      r1,|L8.412|
00010a  9809              LDR      r0,[sp,#0x24]         ;687
00010c  4288              CMP      r0,r1                 ;687
00010e  d9dc              BLS      |L8.202|
                  |L8.272|
000110  bf00              NOP      
                  |L8.274|
000112  1c6d              ADDS     r5,r5,#1              ;681
                  |L8.276|
000114  2d21              CMP      r5,#0x21              ;681
000116  d9ca              BLS      |L8.174|
;;;703                        }
;;;704                    }
;;;705                }
;;;706            }
;;;707        }
;;;708    
;;;709        /* Enable and apply new PLL setting. */
;;;710        CLK->PLLCTL = u32CLK_SRC |
000118  9806              LDR      r0,[sp,#0x18]
00011a  0380              LSLS     r0,r0,#14
00011c  9907              LDR      r1,[sp,#0x1c]
00011e  4308              ORRS     r0,r0,r1
000120  9902              LDR      r1,[sp,#8]
000122  1e89              SUBS     r1,r1,#2
000124  0249              LSLS     r1,r1,#9
000126  4308              ORRS     r0,r0,r1
000128  9903              LDR      r1,[sp,#0xc]
00012a  1e89              SUBS     r1,r1,#2
00012c  4308              ORRS     r0,r0,r1
00012e  4911              LDR      r1,|L8.372|
000130  3140              ADDS     r1,r1,#0x40
000132  6008              STR      r0,[r1,#0]
;;;711                      (u32Outdiv << CLK_PLLCTL_OUTDIV_Pos) |
;;;712                      ((u32MinNR - 2) << CLK_PLLCTL_INDIV_Pos) |
;;;713                      ((u32MinNF - 2) << CLK_PLLCTL_FBDIV_Pos);
;;;714    
;;;715        /* Wait for PLL clock stable */
;;;716        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
000134  2004              MOVS     r0,#4
000136  f7fffffe          BL       CLK_WaitClockReady
;;;717    
;;;718        /* Return actual PLL output clock frequency */
;;;719        return (u32PllSrcClk / (u32NO * u32MinNR) * u32MinNF);
00013a  9a02              LDR      r2,[sp,#8]
00013c  9808              LDR      r0,[sp,#0x20]
00013e  4350              MULS     r0,r2,r0
000140  4601              MOV      r1,r0
000142  980a              LDR      r0,[sp,#0x28]
000144  f7fffffe          BL       __aeabi_uidivmod
000148  9903              LDR      r1,[sp,#0xc]
00014a  4348              MULS     r0,r1,r0
                  |L8.332|
;;;720    
;;;721    lexit:
;;;722    
;;;723        /* Apply default PLL setting and return */
;;;724        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;725            CLK->PLLCTL = CLK_PLLCTL_96MHz_HXT;
;;;726        else
;;;727            CLK->PLLCTL = CLK_PLLCTL_96MHz_HIRC_DIV4;
;;;728    
;;;729        /* Wait for PLL clock stable */
;;;730        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;731    
;;;732        return CLK_GetPLLClockFreq();
;;;733    }
00014c  b00d              ADD      sp,sp,#0x34
00014e  bdf0              POP      {r4-r7,pc}
                  |L8.336|
000150  980b              LDR      r0,[sp,#0x2c]         ;724
000152  2800              CMP      r0,#0                 ;724
000154  d104              BNE      |L8.352|
000156  4812              LDR      r0,|L8.416|
000158  4906              LDR      r1,|L8.372|
00015a  3140              ADDS     r1,r1,#0x40           ;725
00015c  6008              STR      r0,[r1,#0]            ;725
00015e  e003              B        |L8.360|
                  |L8.352|
000160  4810              LDR      r0,|L8.420|
000162  4904              LDR      r1,|L8.372|
000164  3140              ADDS     r1,r1,#0x40           ;727
000166  6008              STR      r0,[r1,#0]            ;727
                  |L8.360|
000168  2004              MOVS     r0,#4                 ;730
00016a  f7fffffe          BL       CLK_WaitClockReady
00016e  f7fffffe          BL       CLK_GetPLLClockFreq
000172  e7eb              B        |L8.332|
;;;734    
                          ENDP

                  |L8.372|
                          DCD      0x40000200
                  |L8.376|
                          DCD      0x01e84800
                  |L8.380|
                          DCD      0x00b71b00
                  |L8.384|
                          DCD      0x08954400
                  |L8.388|
                          DCD      0x05b8d800
                  |L8.392|
                          DCD      0x030a32c0
                  |L8.396|
                          DCD      0x00186a00
                  |L8.400|
                          DCD      0x00f42400
                  |L8.404|
                          DCD      0x0bebc200
                  |L8.408|
                          DCD      0x1dcd6500
                  |L8.412|
                          DCD      0x00000201
                  |L8.416|
                          DCD      0x0000cc5e
                  |L8.420|
                          DCD      0x0008c25e

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_EnableSysTick PROC
;;;794      */
;;;795    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  2200              MOVS     r2,#0
;;;796    {
;;;797        /* Set System Tick counter disabled */
;;;798        SysTick->CTRL = 0;
000002  4b0f              LDR      r3,|L9.64|
000004  611a              STR      r2,[r3,#0x10]
;;;799    
;;;800        /* Set System Tick clock source */
;;;801        if(u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK)
000006  2804              CMP      r0,#4
000008  d106              BNE      |L9.24|
;;;802            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
00000a  461a              MOV      r2,r3
00000c  6912              LDR      r2,[r2,#0x10]
00000e  2304              MOVS     r3,#4
000010  431a              ORRS     r2,r2,r3
000012  4b0b              LDR      r3,|L9.64|
000014  611a              STR      r2,[r3,#0x10]
000016  e006              B        |L9.38|
                  |L9.24|
;;;803        else
;;;804            CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000018  4a0a              LDR      r2,|L9.68|
00001a  6912              LDR      r2,[r2,#0x10]
00001c  2338              MOVS     r3,#0x38
00001e  439a              BICS     r2,r2,r3
000020  4302              ORRS     r2,r2,r0
000022  4b08              LDR      r3,|L9.68|
000024  611a              STR      r2,[r3,#0x10]
                  |L9.38|
;;;805    
;;;806        /* Set System Tick reload value */
;;;807        SysTick->LOAD = u32Count;
000026  4a06              LDR      r2,|L9.64|
000028  6151              STR      r1,[r2,#0x14]
;;;808    
;;;809        /* Clear System Tick current value and counter flag */
;;;810        SysTick->VAL = 0;
00002a  2200              MOVS     r2,#0
00002c  4b04              LDR      r3,|L9.64|
00002e  619a              STR      r2,[r3,#0x18]
;;;811    
;;;812        /* Set System Tick interrupt enabled and counter enabled */
;;;813        SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
000030  461a              MOV      r2,r3
000032  6912              LDR      r2,[r2,#0x10]
000034  2303              MOVS     r3,#3
000036  431a              ORRS     r2,r2,r3
000038  4b01              LDR      r3,|L9.64|
00003a  611a              STR      r2,[r3,#0x10]
;;;814    }
00003c  4770              BX       lr
;;;815    
                          ENDP

00003e  0000              DCW      0x0000
                  |L9.64|
                          DCD      0xe000e000
                  |L9.68|
                          DCD      0x40000200

                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_EnableXtalRC PROC
;;;479      */
;;;480    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L10.12|
;;;481    {
;;;482        CLK->PWRCTL |= u32ClkMask;
000002  6809              LDR      r1,[r1,#0]
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L10.12|
000008  6011              STR      r1,[r2,#0]
;;;483    }
00000a  4770              BX       lr
;;;484    
                          ENDP

                  |L10.12|
                          DCD      0x40000200

                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;202      */
;;;203    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;204    {
;;;205        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;206        return SystemCoreClock;
000006  4801              LDR      r0,|L11.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;207    }
00000a  bd10              POP      {r4,pc}
;;;208    
                          ENDP

                  |L11.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;190      */
;;;191    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;192    {
;;;193        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;194        return SystemCoreClock;
000006  4801              LDR      r0,|L12.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;195    }
00000a  bd10              POP      {r4,pc}
;;;196    
                          ENDP

                  |L12.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;132      */
;;;133    uint32_t CLK_GetHXTFreq(void)
000000  4804              LDR      r0,|L13.20|
;;;134    {
;;;135        if(CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk)
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  0fc0              LSRS     r0,r0,#31
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L13.16|
;;;136            return __HXT;
00000c  4802              LDR      r0,|L13.24|
                  |L13.14|
;;;137        else
;;;138            return 0;
;;;139    }
00000e  4770              BX       lr
                  |L13.16|
000010  2000              MOVS     r0,#0                 ;138
000012  e7fc              B        |L13.14|
;;;140    
                          ENDP

                  |L13.20|
                          DCD      0x40000200
                  |L13.24|
                          DCD      0x01e84800

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetLXTFreq PROC
;;;146      */
;;;147    uint32_t CLK_GetLXTFreq(void)
000000  4804              LDR      r0,|L14.20|
;;;148    {
;;;149        if(CLK->PWRCTL & CLK_PWRCTL_LXTEN_Msk)
000002  6800              LDR      r0,[r0,#0]
000004  2102              MOVS     r1,#2
000006  4008              ANDS     r0,r0,r1
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L14.16|
;;;150            return __LXT;
00000c  0388              LSLS     r0,r1,#14
                  |L14.14|
;;;151        else
;;;152            return 0;
;;;153    }
00000e  4770              BX       lr
                  |L14.16|
000010  2000              MOVS     r0,#0                 ;152
000012  e7fc              B        |L14.14|
;;;154    
                          ENDP

                  |L14.20|
                          DCD      0x40000200

                          AREA ||i.CLK_GetPCLK0Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK0Freq PROC
;;;160      */
;;;161    uint32_t CLK_GetPCLK0Freq(void)
000000  b510              PUSH     {r4,lr}
;;;162    {
;;;163        uint32_t PCLK0Div;
;;;164    
;;;165        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;166        PCLK0Div = (CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) >> CLK_PCLKDIV_APB0DIV_Pos;
000006  4804              LDR      r0,|L15.24|
000008  6b40              LDR      r0,[r0,#0x34]
00000a  0744              LSLS     r4,r0,#29
00000c  0f64              LSRS     r4,r4,#29
;;;167        return (SystemCoreClock >> PCLK0Div);
00000e  4803              LDR      r0,|L15.28|
000010  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000012  40e0              LSRS     r0,r0,r4
;;;168    }
000014  bd10              POP      {r4,pc}
;;;169    
                          ENDP

000016  0000              DCW      0x0000
                  |L15.24|
                          DCD      0x40000200
                  |L15.28|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK1Freq PROC
;;;175      */
;;;176    uint32_t CLK_GetPCLK1Freq(void)
000000  b510              PUSH     {r4,lr}
;;;177    {
;;;178        uint32_t PCLK1Div;
;;;179    
;;;180        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;181        PCLK1Div = (CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) >> CLK_PCLKDIV_APB1DIV_Pos;
000006  4804              LDR      r0,|L16.24|
000008  6b40              LDR      r0,[r0,#0x34]
00000a  2170              MOVS     r1,#0x70
00000c  4008              ANDS     r0,r0,r1
00000e  0904              LSRS     r4,r0,#4
;;;182        return (SystemCoreClock >> PCLK1Div);
000010  4802              LDR      r0,|L16.28|
000012  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000014  40e0              LSRS     r0,r0,r4
;;;183    }
000016  bd10              POP      {r4,pc}
;;;184    
                          ENDP

                  |L16.24|
                          DCD      0x40000200
                  |L16.28|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;456      */
;;;457    static __INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;458    {
;;;459        uint32_t u32PllFreq;
;;;460        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;461        uint8_t au8NoTbl[4] = {1, 2, 2, 4}; /* OUTDIV :DEF: {1, 2, 2, 4} */
000002  a01b              ADR      r0,|L17.112|
000004  6800              LDR      r0,[r0,#0]
000006  9000              STR      r0,[sp,#0]
;;;462        uint32_t u32Reg;
;;;463    
;;;464        u32PllFreq = 0;
000008  2000              MOVS     r0,#0
00000a  9002              STR      r0,[sp,#8]
;;;465        u32Reg = CLK->PLLCTL;
00000c  4819              LDR      r0,|L17.116|
00000e  6804              LDR      r4,[r0,#0]
;;;466    
;;;467        if ((u32Reg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk)) == 0)
000010  2005              MOVS     r0,#5
000012  0400              LSLS     r0,r0,#16
000014  4020              ANDS     r0,r0,r4
000016  2800              CMP      r0,#0
000018  d127              BNE      |L17.106|
;;;468        {
;;;469            /* PLL is enabled and output enabled */
;;;470            if (u32Reg & CLK_PLLCTL_PLLSRC_Msk)
00001a  2001              MOVS     r0,#1
00001c  04c0              LSLS     r0,r0,#19
00001e  4020              ANDS     r0,r0,r4
000020  2800              CMP      r0,#0
000022  d001              BEQ      |L17.40|
;;;471            {
;;;472                u32FIN = (__HIRC >> 2);
000024  4d14              LDR      r5,|L17.120|
000026  e000              B        |L17.42|
                  |L17.40|
;;;473            } else
;;;474                u32FIN = __HXT;
000028  4d14              LDR      r5,|L17.124|
                  |L17.42|
;;;475    
;;;476            if (u32Reg & CLK_PLLCTL_BP_Msk)
00002a  2001              MOVS     r0,#1
00002c  0440              LSLS     r0,r0,#17
00002e  4020              ANDS     r0,r0,r4
000030  2800              CMP      r0,#0
000032  d001              BEQ      |L17.56|
;;;477            {
;;;478                /* PLL is in bypass mode */
;;;479                u32PllFreq = u32FIN;
000034  9502              STR      r5,[sp,#8]
000036  e018              B        |L17.106|
                  |L17.56|
;;;480            }
;;;481            else
;;;482            {
;;;483                /* PLL is in normal work mode */
;;;484                u32NO = au8NoTbl[((u32Reg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
000038  2003              MOVS     r0,#3
00003a  0380              LSLS     r0,r0,#14
00003c  4020              ANDS     r0,r0,r4
00003e  0b80              LSRS     r0,r0,#14
000040  4669              MOV      r1,sp
000042  5c0a              LDRB     r2,[r1,r0]
000044  9201              STR      r2,[sp,#4]
;;;485                u32NF  = ((u32Reg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
000046  05e0              LSLS     r0,r4,#23
000048  0dc0              LSRS     r0,r0,#23
00004a  1c86              ADDS     r6,r0,#2
;;;486                u32NR  = ((u32Reg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
00004c  201f              MOVS     r0,#0x1f
00004e  0240              LSLS     r0,r0,#9
000050  4020              ANDS     r0,r0,r4
000052  0a40              LSRS     r0,r0,#9
000054  1c87              ADDS     r7,r0,#2
;;;487                /* u32FIN is shifted 2 bits to avoid overflow */
;;;488                u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
000056  9a01              LDR      r2,[sp,#4]
000058  437a              MULS     r2,r7,r2
00005a  4611              MOV      r1,r2
00005c  08aa              LSRS     r2,r5,#2
00005e  4372              MULS     r2,r6,r2
000060  4610              MOV      r0,r2
000062  f7fffffe          BL       __aeabi_uidivmod
000066  0080              LSLS     r0,r0,#2
000068  9002              STR      r0,[sp,#8]
                  |L17.106|
;;;489            }
;;;490        }
;;;491    
;;;492        return u32PllFreq;
00006a  9802              LDR      r0,[sp,#8]
;;;493    }
00006c  bdfe              POP      {r1-r7,pc}
;;;494    
                          ENDP

00006e  0000              DCW      0x0000
                  |L17.112|
000070  01020204          DCB      1,2,2,4
                  |L17.116|
                          DCD      0x40000240
                  |L17.120|
                          DCD      0x00b71b00
                  |L17.124|
                          DCD      0x01e84800

                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;114      */
;;;115    void CLK_Idle(void)
000000  4806              LDR      r0,|L18.28|
;;;116    {
;;;117        /* Set the processor uses sleep as its low power mode */
;;;118        SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6900              LDR      r0,[r0,#0x10]
000004  2104              MOVS     r1,#4
000006  4388              BICS     r0,r0,r1
000008  4904              LDR      r1,|L18.28|
00000a  6108              STR      r0,[r1,#0x10]
;;;119    
;;;120        /* Set chip in idle mode because of WFI command */
;;;121        CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
00000c  4804              LDR      r0,|L18.32|
00000e  6800              LDR      r0,[r0,#0]
000010  2180              MOVS     r1,#0x80
000012  4388              BICS     r0,r0,r1
000014  4902              LDR      r1,|L18.32|
000016  6008              STR      r0,[r1,#0]
;;;122    
;;;123        /* Chip enter idle mode after CPU run WFI instruction */
;;;124        __WFI();
000018  bf30              WFI      
;;;125    }
00001a  4770              BX       lr
;;;126    
                          ENDP

                  |L18.28|
                          DCD      0xe000ed00
                  |L18.32|
                          DCD      0x40000200

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;78       */
;;;79     void CLK_PowerDown(void)
000000  b508              PUSH     {r3,lr}
;;;80     {
;;;81         volatile uint32_t u32SysTickTICKINT = 0;    /* Backup Systick interrupt enable bit */
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;82     
;;;83         /* Check HIRC/MIRC auto trim function disable */
;;;84         if(SYS->HIRCTRIMCTL & SYS_HIRCTRIMCTL_FREQSEL_Msk)
000006  4814              LDR      r0,|L19.88|
000008  6b00              LDR      r0,[r0,#0x30]
00000a  0780              LSLS     r0,r0,#30
00000c  0f80              LSRS     r0,r0,#30
00000e  2800              CMP      r0,#0
000010  d000              BEQ      |L19.20|
                  |L19.18|
;;;85         {
;;;86             return;
;;;87         }
;;;88     
;;;89         /* Set the processor uses deep sleep as its low power mode */
;;;90         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
;;;91     
;;;92         /* Set system Power-down enabled */
;;;93         CLK->PWRCTL |= CLK_PWRCTL_PDEN_Msk;
;;;94     
;;;95         /* Backup systick interrupt setting */
;;;96         u32SysTickTICKINT = SysTick->CTRL & SysTick_CTRL_TICKINT_Msk;
;;;97     
;;;98         /* Disable systick interrupt */
;;;99         SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
;;;100    
;;;101        /* Chip enter Power-down mode after CPU run WFI instruction */
;;;102        __WFI();
;;;103    
;;;104        /* Restore systick interrupt setting */
;;;105        if(u32SysTickTICKINT) SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk;
;;;106    }
000012  bd08              POP      {r3,pc}
                  |L19.20|
000014  4811              LDR      r0,|L19.92|
000016  6900              LDR      r0,[r0,#0x10]         ;90
000018  2104              MOVS     r1,#4                 ;90
00001a  4308              ORRS     r0,r0,r1              ;90
00001c  490f              LDR      r1,|L19.92|
00001e  6108              STR      r0,[r1,#0x10]         ;90
000020  480f              LDR      r0,|L19.96|
000022  6800              LDR      r0,[r0,#0]            ;93
000024  2180              MOVS     r1,#0x80              ;93
000026  4308              ORRS     r0,r0,r1              ;93
000028  490d              LDR      r1,|L19.96|
00002a  6008              STR      r0,[r1,#0]            ;93
00002c  480d              LDR      r0,|L19.100|
00002e  6900              LDR      r0,[r0,#0x10]         ;96
000030  2102              MOVS     r1,#2                 ;96
000032  4008              ANDS     r0,r0,r1              ;96
000034  9000              STR      r0,[sp,#0]            ;96
000036  480b              LDR      r0,|L19.100|
000038  6900              LDR      r0,[r0,#0x10]         ;99
00003a  4388              BICS     r0,r0,r1              ;99
00003c  4909              LDR      r1,|L19.100|
00003e  6108              STR      r0,[r1,#0x10]         ;99
000040  bf30              WFI                            ;102
000042  9800              LDR      r0,[sp,#0]            ;105
000044  2800              CMP      r0,#0                 ;105
000046  d005              BEQ      |L19.84|
000048  4608              MOV      r0,r1                 ;105
00004a  6900              LDR      r0,[r0,#0x10]         ;105
00004c  2102              MOVS     r1,#2                 ;105
00004e  4308              ORRS     r0,r0,r1              ;105
000050  4904              LDR      r1,|L19.100|
000052  6108              STR      r0,[r1,#0x10]         ;105
                  |L19.84|
000054  bf00              NOP      
000056  e7dc              B        |L19.18|
;;;107    
                          ENDP

                  |L19.88|
                          DCD      0x400000c0
                  |L19.92|
                          DCD      0xe000ed00
                  |L19.96|
                          DCD      0x40000200
                  |L19.100|
                          DCD      0xe000e000

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;219      */
;;;220    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b570              PUSH     {r4-r6,lr}
;;;221    {
000002  4604              MOV      r4,r0
;;;222        uint32_t u32HIRCSTB;
;;;223        uint32_t u32HCLK_UpperLimit;
;;;224    
;;;225        /* Read HIRC clock source stable flag */
;;;226        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000004  482e              LDR      r0,|L20.192|
000006  6900              LDR      r0,[r0,#0x10]
000008  2110              MOVS     r1,#0x10
00000a  4008              ANDS     r0,r0,r1
00000c  4606              MOV      r6,r0
;;;227    
;;;228        /* The range of u32Hclk is 25.5 MHz ~ 48 MHz or 72 MHz */
;;;229        if ((GET_CHIP_SERIES_NUM == CHIP_SERIES_NUM_G) || (GET_CHIP_SERIES_NUM == CHIP_SERIES_NUM_I))
00000e  0688              LSLS     r0,r1,#26
000010  6800              LDR      r0,[r0,#0]
000012  210f              MOVS     r1,#0xf
000014  0209              LSLS     r1,r1,#8
000016  4008              ANDS     r0,r0,r1
000018  0a00              LSRS     r0,r0,#8
00001a  2806              CMP      r0,#6
00001c  d006              BEQ      |L20.44|
00001e  2001              MOVS     r0,#1
000020  0780              LSLS     r0,r0,#30
000022  6800              LDR      r0,[r0,#0]
000024  4008              ANDS     r0,r0,r1
000026  0a00              LSRS     r0,r0,#8
000028  2801              CMP      r0,#1
00002a  d101              BNE      |L20.48|
                  |L20.44|
;;;230            u32HCLK_UpperLimit = FREQ_72MHZ;
00002c  4d25              LDR      r5,|L20.196|
00002e  e000              B        |L20.50|
                  |L20.48|
;;;231        else
;;;232            u32HCLK_UpperLimit = FREQ_48MHZ;
000030  4d25              LDR      r5,|L20.200|
                  |L20.50|
;;;233    
;;;234        if(u32Hclk > u32HCLK_UpperLimit)
000032  42ac              CMP      r4,r5
000034  d900              BLS      |L20.56|
;;;235            u32Hclk = u32HCLK_UpperLimit;
000036  462c              MOV      r4,r5
                  |L20.56|
;;;236        if(u32Hclk < (FREQ_51MHZ >> 1))
000038  4824              LDR      r0,|L20.204|
00003a  4284              CMP      r4,r0
00003c  d200              BCS      |L20.64|
;;;237            u32Hclk = (FREQ_51MHZ >> 1);
00003e  4604              MOV      r4,r0
                  |L20.64|
;;;238    
;;;239        /* Switch HCLK clock source to HIRC clock for safe */
;;;240        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000040  481f              LDR      r0,|L20.192|
000042  3840              SUBS     r0,r0,#0x40
000044  6800              LDR      r0,[r0,#0]
000046  2104              MOVS     r1,#4
000048  4308              ORRS     r0,r0,r1
00004a  491d              LDR      r1,|L20.192|
00004c  3940              SUBS     r1,r1,#0x40
00004e  6008              STR      r0,[r1,#0]
;;;241        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000050  2010              MOVS     r0,#0x10
000052  f7fffffe          BL       CLK_WaitClockReady
;;;242        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
000056  481a              LDR      r0,|L20.192|
000058  3840              SUBS     r0,r0,#0x40
00005a  6900              LDR      r0,[r0,#0x10]
00005c  2107              MOVS     r1,#7
00005e  4308              ORRS     r0,r0,r1
000060  4917              LDR      r1,|L20.192|
000062  3940              SUBS     r1,r1,#0x40
000064  6108              STR      r0,[r1,#0x10]
;;;243        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
000066  4608              MOV      r0,r1
000068  6a00              LDR      r0,[r0,#0x20]
00006a  0900              LSRS     r0,r0,#4
00006c  0100              LSLS     r0,r0,#4
00006e  6208              STR      r0,[r1,#0x20]
;;;244    
;;;245        /* Configure PLL setting if HXT clock is stable */
;;;246        if(CLK->STATUS & CLK_STATUS_HXTSTB_Msk)
000070  4813              LDR      r0,|L20.192|
000072  6900              LDR      r0,[r0,#0x10]
000074  07c0              LSLS     r0,r0,#31
000076  0fc0              LSRS     r0,r0,#31
000078  2800              CMP      r0,#0
00007a  d005              BEQ      |L20.136|
;;;247            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, (u32Hclk << 1));
00007c  0061              LSLS     r1,r4,#1
00007e  2000              MOVS     r0,#0
000080  f7fffffe          BL       CLK_EnablePLL
000084  4604              MOV      r4,r0
000086  e00a              B        |L20.158|
                  |L20.136|
;;;248    
;;;249        /* Configure PLL setting if HXT clock is not stable */
;;;250        else
;;;251        {
;;;252            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC_DIV4, (u32Hclk << 1));
000088  0061              LSLS     r1,r4,#1
00008a  2001              MOVS     r0,#1
00008c  04c0              LSLS     r0,r0,#19
00008e  f7fffffe          BL       CLK_EnablePLL
000092  4604              MOV      r4,r0
;;;253    
;;;254            /* Read HIRC clock source stable flag */
;;;255            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000094  480a              LDR      r0,|L20.192|
000096  6900              LDR      r0,[r0,#0x10]
000098  2110              MOVS     r1,#0x10
00009a  4008              ANDS     r0,r0,r1
00009c  4606              MOV      r6,r0
                  |L20.158|
;;;256        }
;;;257    
;;;258        /* Select HCLK clock source to PLL,
;;;259           Select HCLK clock source divider as 2
;;;260           and update system core clock
;;;261        */
;;;262        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(2));
00009e  2101              MOVS     r1,#1
0000a0  2002              MOVS     r0,#2
0000a2  f7fffffe          BL       CLK_SetHCLK
;;;263    
;;;264        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;265        if(u32HIRCSTB == 0)
0000a6  2e00              CMP      r6,#0
0000a8  d107              BNE      |L20.186|
;;;266            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
0000aa  4805              LDR      r0,|L20.192|
0000ac  3840              SUBS     r0,r0,#0x40
0000ae  6800              LDR      r0,[r0,#0]
0000b0  2104              MOVS     r1,#4
0000b2  4388              BICS     r0,r0,r1
0000b4  4902              LDR      r1,|L20.192|
0000b6  3940              SUBS     r1,r1,#0x40
0000b8  6008              STR      r0,[r1,#0]
                  |L20.186|
;;;267    
;;;268        /* Return actually HCLK frequency is PLL frequency divide 2 */
;;;269        return u32Hclk >> 1;
0000ba  0860              LSRS     r0,r4,#1
;;;270    }
0000bc  bd70              POP      {r4-r6,pc}
;;;271    
                          ENDP

0000be  0000              DCW      0x0000
                  |L20.192|
                          DCD      0x40000240
                  |L20.196|
                          DCD      0x044aa200
                  |L20.200|
                          DCD      0x02dc6c00
                  |L20.204|
                          DCD      0x01851960

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=2

                  CLK_SetHCLK PROC
;;;285      */
;;;286    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b570              PUSH     {r4-r6,lr}
;;;287    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;288        uint32_t u32HIRCSTB;
;;;289    
;;;290        /* Read HIRC clock source stable flag */
;;;291        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000006  4819              LDR      r0,|L21.108|
000008  6900              LDR      r0,[r0,#0x10]
00000a  2110              MOVS     r1,#0x10
00000c  4008              ANDS     r0,r0,r1
00000e  4606              MOV      r6,r0
;;;292    
;;;293        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;294        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000010  4816              LDR      r0,|L21.108|
000012  3840              SUBS     r0,r0,#0x40
000014  6800              LDR      r0,[r0,#0]
000016  2104              MOVS     r1,#4
000018  4308              ORRS     r0,r0,r1
00001a  4914              LDR      r1,|L21.108|
00001c  3940              SUBS     r1,r1,#0x40
00001e  6008              STR      r0,[r1,#0]
;;;295        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000020  2010              MOVS     r0,#0x10
000022  f7fffffe          BL       CLK_WaitClockReady
;;;296        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
000026  4811              LDR      r0,|L21.108|
000028  3840              SUBS     r0,r0,#0x40
00002a  6900              LDR      r0,[r0,#0x10]
00002c  08c0              LSRS     r0,r0,#3
00002e  00c0              LSLS     r0,r0,#3
000030  1dc0              ADDS     r0,r0,#7
000032  490e              LDR      r1,|L21.108|
000034  3940              SUBS     r1,r1,#0x40
000036  6108              STR      r0,[r1,#0x10]
;;;297    
;;;298        /* Apply new Divider */
;;;299        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
000038  4608              MOV      r0,r1
00003a  6a00              LDR      r0,[r0,#0x20]
00003c  0900              LSRS     r0,r0,#4
00003e  0100              LSLS     r0,r0,#4
000040  4328              ORRS     r0,r0,r5
000042  6208              STR      r0,[r1,#0x20]
;;;300    
;;;301        /* Switch HCLK to new HCLK source */
;;;302        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
000044  4608              MOV      r0,r1
000046  6900              LDR      r0,[r0,#0x10]
000048  08c0              LSRS     r0,r0,#3
00004a  00c0              LSLS     r0,r0,#3
00004c  4320              ORRS     r0,r0,r4
00004e  6108              STR      r0,[r1,#0x10]
;;;303    
;;;304        /* Update System Core Clock */
;;;305        SystemCoreClockUpdate();
000050  f7fffffe          BL       SystemCoreClockUpdate
;;;306    
;;;307        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;308        if(u32HIRCSTB == 0)
000054  2e00              CMP      r6,#0
000056  d107              BNE      |L21.104|
;;;309            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000058  4804              LDR      r0,|L21.108|
00005a  3840              SUBS     r0,r0,#0x40
00005c  6800              LDR      r0,[r0,#0]
00005e  2104              MOVS     r1,#4
000060  4388              BICS     r0,r0,r1
000062  4902              LDR      r1,|L21.108|
000064  3940              SUBS     r1,r1,#0x40
000066  6008              STR      r0,[r1,#0]
                  |L21.104|
;;;310    }
000068  bd70              POP      {r4-r6,pc}
;;;311    
                          ENDP

00006a  0000              DCW      0x0000
                  |L21.108|
                          DCD      0x40000240

                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;428      */
;;;429    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;430    {
000002  b088              SUB      sp,sp,#0x20
;;;431        uint32_t u32sel = 0, u32div = 0;
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;432        uint32_t u32SelTbl[4] = {0x0, 0x4, 0x8, 0xC};   /* CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1, 0x2:CLKSEL2, 0x3:CLKSEL3 */
000008  4c1e              LDR      r4,|L22.132|
00000a  4625              MOV      r5,r4
00000c  cde0              LDM      r5,{r5-r7}
00000e  68e4              LDR      r4,[r4,#0xc]  ; <Data1>
000010  9706              STR      r7,[sp,#0x18]
000012  9605              STR      r6,[sp,#0x14]
000014  9504              STR      r5,[sp,#0x10]
000016  9407              STR      r4,[sp,#0x1c]
;;;433        uint32_t u32DivTbl[4] = {0x0, 0x0, 0x0, 0x10};  /* CLKDIV offset on MODULE index, 0x0:CLKDIV0, 0x1:CLKDIV1, 0x2:CLKDIV3, 0x3:CLKDIV4 */
000018  4c1a              LDR      r4,|L22.132|
00001a  3410              ADDS     r4,r4,#0x10
00001c  4625              MOV      r5,r4
00001e  cde0              LDM      r5,{r5-r7}
000020  68e4              LDR      r4,[r4,#0xc]  ; <Data2>
000022  9702              STR      r7,[sp,#8]
000024  9601              STR      r6,[sp,#4]
000026  9500              STR      r5,[sp,#0]
000028  9403              STR      r4,[sp,#0xc]
;;;434    
;;;435        if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
00002a  0384              LSLS     r4,r0,#14
00002c  0e24              LSRS     r4,r4,#24
00002e  2c00              CMP      r4,#0
000030  d010              BEQ      |L22.84|
;;;436        {
;;;437            /* Get clock divider control register address */
;;;438            u32div = (uint32_t)&CLK->CLKDIV0 + (u32DivTbl[MODULE_CLKDIV(u32ModuleIdx)]);
000032  0304              LSLS     r4,r0,#12
000034  0fa4              LSRS     r4,r4,#30
000036  00a4              LSLS     r4,r4,#2
000038  466d              MOV      r5,sp
00003a  592c              LDR      r4,[r5,r4]
00003c  4d12              LDR      r5,|L22.136|
00003e  1963              ADDS     r3,r4,r5
;;;439            /* Apply new divider */
;;;440            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
000040  0384              LSLS     r4,r0,#14
000042  0e25              LSRS     r5,r4,#24
000044  0584              LSLS     r4,r0,#22
000046  0ee4              LSRS     r4,r4,#27
000048  40a5              LSLS     r5,r5,r4
00004a  681c              LDR      r4,[r3,#0]
00004c  43ac              BICS     r4,r4,r5
00004e  9d0a              LDR      r5,[sp,#0x28]
000050  432c              ORRS     r4,r4,r5
000052  601c              STR      r4,[r3,#0]
                  |L22.84|
;;;441        }
;;;442    
;;;443        if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
000054  0104              LSLS     r4,r0,#4
000056  0f64              LSRS     r4,r4,#29
000058  2c00              CMP      r4,#0
00005a  d010              BEQ      |L22.126|
;;;444        {
;;;445            /* Get clock select control register address */
;;;446            u32sel = (uint32_t)&CLK->CLKSEL0 + (u32SelTbl[MODULE_CLKSEL(u32ModuleIdx)]);
00005c  0084              LSLS     r4,r0,#2
00005e  0fa4              LSRS     r4,r4,#30
000060  00a4              LSLS     r4,r4,#2
000062  ad04              ADD      r5,sp,#0x10
000064  592c              LDR      r4,[r5,r4]
000066  4d08              LDR      r5,|L22.136|
000068  3d10              SUBS     r5,r5,#0x10
00006a  1962              ADDS     r2,r4,r5
;;;447            /* Set new clock selection setting */
;;;448            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
00006c  0104              LSLS     r4,r0,#4
00006e  0f65              LSRS     r5,r4,#29
000070  01c4              LSLS     r4,r0,#7
000072  0ee4              LSRS     r4,r4,#27
000074  40a5              LSLS     r5,r5,r4
000076  6814              LDR      r4,[r2,#0]
000078  43ac              BICS     r4,r4,r5
00007a  430c              ORRS     r4,r4,r1
00007c  6014              STR      r4,[r2,#0]
                  |L22.126|
;;;449        }
;;;450    }
00007e  b00b              ADD      sp,sp,#0x2c
000080  bdf0              POP      {r4-r7,pc}
;;;451    
                          ENDP

000082  0000              DCW      0x0000
                  |L22.132|
                          DCD      ||.constdata||
                  |L22.136|
                          DCD      0x40000220

                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=2

                  CLK_SetSysTickClockSrc PROC
;;;463      */
;;;464    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  4903              LDR      r1,|L23.16|
;;;465    {
;;;466        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000002  6909              LDR      r1,[r1,#0x10]
000004  2238              MOVS     r2,#0x38
000006  4391              BICS     r1,r1,r2
000008  4301              ORRS     r1,r1,r0
00000a  4a01              LDR      r2,|L23.16|
00000c  6111              STR      r1,[r2,#0x10]
;;;467    }
00000e  4770              BX       lr
;;;468    
                          ENDP

                  |L23.16|
                          DCD      0x40000200

                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;767      */
;;;768    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  4601              MOV      r1,r0
;;;769    {
;;;770        int32_t i32TimeOutCnt = 3096000;
000002  4a07              LDR      r2,|L24.32|
;;;771    
;;;772        while((CLK->STATUS & u32ClkMask) != u32ClkMask)
000004  e005              B        |L24.18|
                  |L24.6|
;;;773        {
;;;774            if(i32TimeOutCnt-- <= 0)
000006  4610              MOV      r0,r2
000008  1e52              SUBS     r2,r2,#1
00000a  2800              CMP      r0,#0
00000c  dc01              BGT      |L24.18|
;;;775                return 0;
00000e  2000              MOVS     r0,#0
                  |L24.16|
;;;776        }
;;;777    
;;;778        return 1;
;;;779    }
000010  4770              BX       lr
                  |L24.18|
000012  4804              LDR      r0,|L24.36|
000014  6900              LDR      r0,[r0,#0x10]         ;772
000016  4008              ANDS     r0,r0,r1              ;772
000018  4288              CMP      r0,r1                 ;772
00001a  d1f4              BNE      |L24.6|
00001c  2001              MOVS     r0,#1                 ;778
00001e  e7f7              B        |L24.16|
;;;780    
                          ENDP

                  |L24.32|
                          DCD      0x002f3dc0
                  |L24.36|
                          DCD      0x40000240

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x0000000c
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000010
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 402
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
