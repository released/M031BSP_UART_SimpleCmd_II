; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.CRC8||, CODE, READONLY, ALIGN=2

                  CRC8 PROC
;;;413    
;;;414    uint8_t CRC8( uint8_t *buf, uint16_t len)     
000000  b510              PUSH     {r4,lr}
;;;415    {               
000002  4602              MOV      r2,r0
;;;416    	uint8_t  crc=0;
000004  2000              MOVS     r0,#0
;;;417    
;;;418    	while ( len-- )     
000006  e004              B        |L1.18|
                  |L1.8|
;;;419    	{   
;;;420    		crc = CRC8TAB[crc^*buf]; 
000008  7813              LDRB     r3,[r2,#0]
00000a  4043              EORS     r3,r3,r0
00000c  4c04              LDR      r4,|L1.32|
00000e  5ce0              LDRB     r0,[r4,r3]
;;;421    
;;;422    		buf++;   
000010  1c52              ADDS     r2,r2,#1
                  |L1.18|
000012  460b              MOV      r3,r1                 ;418
000014  1e4c              SUBS     r4,r1,#1              ;418
000016  b2a1              UXTH     r1,r4                 ;418
000018  2b00              CMP      r3,#0                 ;418
00001a  d1f5              BNE      |L1.8|
;;;423    	}     
;;;424    
;;;425    	return crc;     
;;;426    }  
00001c  bd10              POP      {r4,pc}
;;;427    
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      CRC8TAB

                          AREA ||i.CRC_CAL_SAMPLE||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                  CRC_CAL_SAMPLE PROC
;;;633    
;;;634    void CRC_CAL_SAMPLE(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;635    {   
;;;636        uint8_t buf[6] = {0};
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  9001              STR      r0,[sp,#4]
;;;637        uint8_t res = 0 ;
000008  2500              MOVS     r5,#0
;;;638        uint8_t i = 0;
00000a  2400              MOVS     r4,#0
;;;639    
;;;640        buf[fmt_head] = UART_CMD_FMT_HEAD;
00000c  215a              MOVS     r1,#0x5a
00000e  4668              MOV      r0,sp
000010  7001              STRB     r1,[r0,#0]
;;;641        buf[fmt_code] = UART_CMD_FMT_CODE4;
000012  2104              MOVS     r1,#4
000014  7041              STRB     r1,[r0,#1]
;;;642        buf[fmt_data_0] = 0x11;
000016  2111              MOVS     r1,#0x11
000018  7081              STRB     r1,[r0,#2]
;;;643        buf[fmt_data_1] = 0x22;
00001a  2122              MOVS     r1,#0x22
00001c  70c1              STRB     r1,[r0,#3]
;;;644        buf[fmt_data_2] = 0x33;
00001e  2133              MOVS     r1,#0x33
000020  7101              STRB     r1,[r0,#4]
;;;645        buf[fmt_data_3] = 0x44;
000022  2144              MOVS     r1,#0x44
000024  7141              STRB     r1,[r0,#5]
;;;646        
;;;647        for(i = 0 ; i < 6 ; i++)
000026  bf00              NOP      
000028  e007              B        |L2.58|
                  |L2.42|
;;;648        {
;;;649            printf("%d:0x%2X\r\n" , i , buf[i]);
00002a  4668              MOV      r0,sp
00002c  5d02              LDRB     r2,[r0,r4]
00002e  4621              MOV      r1,r4
000030  a008              ADR      r0,|L2.84|
000032  f7fffffe          BL       __2printf
000036  1c60              ADDS     r0,r4,#1              ;647
000038  b2c4              UXTB     r4,r0                 ;647
                  |L2.58|
00003a  2c06              CMP      r4,#6                 ;647
00003c  dbf5              BLT      |L2.42|
;;;650        }
;;;651    
;;;652        res = CRC8(buf,6);
00003e  2106              MOVS     r1,#6
000040  4668              MOV      r0,sp
000042  f7fffffe          BL       CRC8
000046  4605              MOV      r5,r0
;;;653        printf("CRC8 : 0x%2X\r\n",res);
000048  4629              MOV      r1,r5
00004a  a005              ADR      r0,|L2.96|
00004c  f7fffffe          BL       __2printf
;;;654    
;;;655    /*
;;;656        CRC8 
;;;657    
;;;658        TEST cmd receive CORRECT
;;;659        HEAD :0x5A + CODE :0x01 + 0x01 + 0x02 + 0x03 + 0x04 = 0xAA
;;;660        HEAD :0x5A + CODE :0x02 + 0x20 + 0x30 + 0x40 + 0x50 = 0x4A
;;;661        HEAD :0x5A + CODE :0x03 + 0x7F + 0x7E + 0x7D + 0x7C = 0xC3
;;;662        HEAD :0x5A + CODE :0x04 + 0x11 + 0x22 + 0x33 + 0x44 = 0xA8
;;;663    
;;;664    
;;;665        TEST cmd receive CODE INCORRECT
;;;666        HEAD :0x5A + CODE :0x05 + 0x20 + 0x30 + 0x40 + 0x50 = 0x11
;;;667    
;;;668        TEST cmd receive CS INCORRECT
;;;669        HEAD :0x5A + CODE :0x02 + 0x20 + 0x30 + 0x40 + 0x50
;;;670    
;;;671        TEST cmd receive HEAD INCORRECT
;;;672        HEAD :0x5C + CODE :0x02 + 0x20 + 0x30 + 0x40 + 0x50 
;;;673    
;;;674        TEST cmd receive HEAD INCORRECT
;;;675        HEAD :0x5A + CODE :0x02 + 0x20 + 0x30 + 0x40 + 0x50 
;;;676    
;;;677    
;;;678    */
;;;679    
;;;680    }
000050  bd7c              POP      {r2-r6,pc}
;;;681    
                          ENDP

000052  0000              DCW      0x0000
                  |L2.84|
000054  25643a30          DCB      "%d:0x%2X\r\n",0
000058  78253258
00005c  0d0a00  
00005f  00                DCB      0
                  |L2.96|
000060  43524338          DCB      "CRC8 : 0x%2X\r\n",0
000064  203a2030
000068  78253258
00006c  0d0a00  
00006f  00                DCB      0

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;773    
;;;774    void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;775    {
;;;776        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB14MFP_Msk)) | (SYS_GPB_MFPH_PB14MFP_GPIO);
000002  2001              MOVS     r0,#1
000004  0780              LSLS     r0,r0,#30
000006  6bc0              LDR      r0,[r0,#0x3c]
000008  210f              MOVS     r1,#0xf
00000a  0609              LSLS     r1,r1,#24
00000c  4388              BICS     r0,r0,r1
00000e  2101              MOVS     r1,#1
000010  0789              LSLS     r1,r1,#30
000012  63c8              STR      r0,[r1,#0x3c]
;;;777        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB15MFP_Msk)) | (SYS_GPB_MFPH_PB15MFP_GPIO);
000014  4608              MOV      r0,r1
000016  6bc0              LDR      r0,[r0,#0x3c]
000018  0100              LSLS     r0,r0,#4
00001a  0900              LSRS     r0,r0,#4
00001c  63c8              STR      r0,[r1,#0x3c]
;;;778    
;;;779        GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT);
00001e  2201              MOVS     r2,#1
000020  1409              ASRS     r1,r1,#16
000022  4804              LDR      r0,|L3.52|
000024  f7fffffe          BL       GPIO_SetMode
;;;780        GPIO_SetMode(PB, BIT15, GPIO_MODE_OUTPUT);	
000028  2201              MOVS     r2,#1
00002a  03d1              LSLS     r1,r2,#15
00002c  4801              LDR      r0,|L3.52|
00002e  f7fffffe          BL       GPIO_SetMode
;;;781    
;;;782    }
000032  bd10              POP      {r4,pc}
;;;783    
                          ENDP

                  |L3.52|
                          DCD      0x40004040

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_EnableIRQ PROC
;;;628     */
;;;629    __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;630    {
;;;631      NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L4.16|
00000a  6011              STR      r1,[r2,#0]
;;;632    }
00000c  4770              BX       lr
;;;633    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      0xe000e100

                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;687     */
;;;688    __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;689    {
;;;690      if ((int32_t)(IRQn) < 0)
000002  2800              CMP      r0,#0
000004  da19              BGE      |L5.58|
;;;691      {
;;;692        SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
000006  4a1a              LDR      r2,|L5.112|
000008  0703              LSLS     r3,r0,#28
00000a  0f1b              LSRS     r3,r3,#28
00000c  3b08              SUBS     r3,r3,#8
00000e  089b              LSRS     r3,r3,#2
000010  009b              LSLS     r3,r3,#2
000012  58d2              LDR      r2,[r2,r3]
000014  0783              LSLS     r3,r0,#30
000016  0edc              LSRS     r4,r3,#27
000018  23ff              MOVS     r3,#0xff
00001a  40a3              LSLS     r3,r3,r4
00001c  439a              BICS     r2,r2,r3
00001e  078b              LSLS     r3,r1,#30
000020  0e1b              LSRS     r3,r3,#24
000022  0784              LSLS     r4,r0,#30
000024  0ee4              LSRS     r4,r4,#27
000026  40a3              LSLS     r3,r3,r4
000028  431a              ORRS     r2,r2,r3
00002a  4b11              LDR      r3,|L5.112|
00002c  0704              LSLS     r4,r0,#28
00002e  0f24              LSRS     r4,r4,#28
000030  3c08              SUBS     r4,r4,#8
000032  08a4              LSRS     r4,r4,#2
000034  00a4              LSLS     r4,r4,#2
000036  511a              STR      r2,[r3,r4]
000038  e018              B        |L5.108|
                  |L5.58|
;;;693           (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
;;;694      }
;;;695      else
;;;696      {
;;;697        NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
00003a  4a0e              LDR      r2,|L5.116|
00003c  2303              MOVS     r3,#3
00003e  021b              LSLS     r3,r3,#8
000040  18d2              ADDS     r2,r2,r3
000042  0883              LSRS     r3,r0,#2
000044  009b              LSLS     r3,r3,#2
000046  58d2              LDR      r2,[r2,r3]
000048  0783              LSLS     r3,r0,#30
00004a  0edc              LSRS     r4,r3,#27
00004c  23ff              MOVS     r3,#0xff
00004e  40a3              LSLS     r3,r3,r4
000050  439a              BICS     r2,r2,r3
000052  078b              LSLS     r3,r1,#30
000054  0e1b              LSRS     r3,r3,#24
000056  0784              LSLS     r4,r0,#30
000058  0ee4              LSRS     r4,r4,#27
00005a  40a3              LSLS     r3,r3,r4
00005c  431a              ORRS     r2,r2,r3
00005e  4b05              LDR      r3,|L5.116|
000060  2403              MOVS     r4,#3
000062  0224              LSLS     r4,r4,#8
000064  191b              ADDS     r3,r3,r4
000066  0884              LSRS     r4,r0,#2
000068  00a4              LSLS     r4,r4,#2
00006a  511a              STR      r2,[r3,r4]
                  |L5.108|
;;;698           (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
;;;699      }
;;;700    }
00006c  bd10              POP      {r4,pc}
;;;701    
                          ENDP

00006e  0000              DCW      0x0000
                  |L5.112|
                          DCD      0xe000ed1c
                  |L5.116|
                          DCD      0xe000e100

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;783    
;;;784    void SYS_Init(void)
000000  b510              PUSH     {r4,lr}
;;;785    {
;;;786        /* Unlock protected registers */
;;;787        SYS_UnlockReg();
000002  bf00              NOP      
000004  bf00              NOP      
000006  bf00              NOP      
                  |L6.8|
000008  2059              MOVS     r0,#0x59
00000a  4925              LDR      r1,|L6.160|
00000c  6008              STR      r0,[r1,#0]
00000e  2016              MOVS     r0,#0x16
000010  6008              STR      r0,[r1,#0]
000012  2088              MOVS     r0,#0x88
000014  6008              STR      r0,[r1,#0]
000016  4608              MOV      r0,r1
000018  6800              LDR      r0,[r0,#0]
00001a  2800              CMP      r0,#0
00001c  d0f4              BEQ      |L6.8|
00001e  bf00              NOP      
;;;788    
;;;789        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;790        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
000020  4820              LDR      r0,|L6.164|
000022  6800              LDR      r0,[r0,#0]
000024  21f0              MOVS     r1,#0xf0
000026  4388              BICS     r0,r0,r1
000028  491e              LDR      r1,|L6.164|
00002a  6008              STR      r0,[r1,#0]
;;;791        
;;;792        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
00002c  2004              MOVS     r0,#4
00002e  f7fffffe          BL       CLK_EnableXtalRC
;;;793        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000032  2010              MOVS     r0,#0x10
000034  f7fffffe          BL       CLK_WaitClockReady
;;;794    
;;;795    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;796    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;797    
;;;798    //    CLK_EnableXtalRC(CLK_PWRCTL_LIRCEN_Msk);
;;;799    //    CLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);	
;;;800    
;;;801    //    CLK_EnableXtalRC(CLK_PWRCTL_LXTEN_Msk);
;;;802    //    CLK_WaitClockReady(CLK_STATUS_LXTSTB_Msk);	
;;;803    
;;;804        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;805        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000038  2100              MOVS     r1,#0
00003a  2007              MOVS     r0,#7
00003c  f7fffffe          BL       CLK_SetHCLK
;;;806    
;;;807        CLK_EnableModuleClock(UART0_MODULE);
000040  4819              LDR      r0,|L6.168|
000042  f7fffffe          BL       CLK_EnableModuleClock
;;;808        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));
000046  2200              MOVS     r2,#0
000048  2103              MOVS     r1,#3
00004a  0609              LSLS     r1,r1,#24
00004c  4816              LDR      r0,|L6.168|
00004e  f7fffffe          BL       CLK_SetModuleClock
;;;809    
;;;810        CLK_EnableModuleClock(TMR0_MODULE);
000052  4816              LDR      r0,|L6.172|
000054  f7fffffe          BL       CLK_EnableModuleClock
;;;811      	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HIRC, 0);
000058  2200              MOVS     r2,#0
00005a  2107              MOVS     r1,#7
00005c  0209              LSLS     r1,r1,#8
00005e  4813              LDR      r0,|L6.172|
000060  f7fffffe          BL       CLK_SetModuleClock
;;;812    
;;;813        CLK_EnableModuleClock(TMR1_MODULE);
000064  4812              LDR      r0,|L6.176|
000066  f7fffffe          BL       CLK_EnableModuleClock
;;;814      	CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
00006a  2200              MOVS     r2,#0
00006c  2107              MOVS     r1,#7
00006e  0309              LSLS     r1,r1,#12
000070  480f              LDR      r0,|L6.176|
000072  f7fffffe          BL       CLK_SetModuleClock
;;;815    
;;;816        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;817        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk)) |
000076  2001              MOVS     r0,#1
000078  0780              LSLS     r0,r0,#30
00007a  6bc0              LDR      r0,[r0,#0x3c]
00007c  21ff              MOVS     r1,#0xff
00007e  0409              LSLS     r1,r1,#16
000080  4388              BICS     r0,r0,r1
000082  2133              MOVS     r1,#0x33
000084  0449              LSLS     r1,r1,#17
000086  1840              ADDS     r0,r0,r1
000088  2101              MOVS     r1,#1
00008a  0789              LSLS     r1,r1,#30
00008c  63c8              STR      r0,[r1,#0x3c]
;;;818                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;819    
;;;820       /* Update System Core Clock */
;;;821        SystemCoreClockUpdate();
00008e  f7fffffe          BL       SystemCoreClockUpdate
;;;822    
;;;823        /* Lock protected registers */
;;;824        SYS_LockReg();
000092  bf00              NOP      
000094  2000              MOVS     r0,#0
000096  4902              LDR      r1,|L6.160|
000098  6008              STR      r0,[r1,#0]
00009a  bf00              NOP      
;;;825    }
00009c  bd10              POP      {r4,pc}
;;;826    
                          ENDP

00009e  0000              DCW      0x0000
                  |L6.160|
                          DCD      0x40000100
                  |L6.164|
                          DCD      0x40004140
                  |L6.168|
                          DCD      0x5f803d10
                  |L6.172|
                          DCD      0x5e800002
                  |L6.176|
                          DCD      0x5ec00003

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=1

                  SysTick_Handler PROC
;;;366    
;;;367    void SysTick_Handler(void)
000000  b500              PUSH     {lr}
;;;368    {
;;;369    
;;;370        systick_counter();
000002  f7fffffe          BL       systick_counter
;;;371    
;;;372        if (get_systick() >= 0xFFFFFFFF)
000006  f7fffffe          BL       get_systick
00000a  1c40              ADDS     r0,r0,#1
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L7.20|
;;;373        {
;;;374            set_systick(0);      
000010  f7fffffe          BL       set_systick
                  |L7.20|
;;;375        }
;;;376    
;;;377        // if ((get_systick() % 1000) == 0)
;;;378        // {
;;;379           
;;;380        // }
;;;381    
;;;382        #if defined (ENABLE_TICK_EVENT)
;;;383        TickCheckTickEvent();
;;;384        #endif    
;;;385    }
000014  bd00              POP      {pc}
;;;386    
                          ENDP


                          AREA ||i.SysTick_delay||, CODE, READONLY, ALIGN=1

                  SysTick_delay PROC
;;;386    
;;;387    void SysTick_delay(unsigned long delay)
000000  b500              PUSH     {lr}
;;;388    {  
000002  4601              MOV      r1,r0
;;;389        
;;;390        uint32_t tickstart = get_systick(); 
000004  f7fffffe          BL       get_systick
000008  4602              MOV      r2,r0
;;;391        uint32_t wait = delay; 
00000a  460b              MOV      r3,r1
;;;392    
;;;393        while((get_systick() - tickstart) < wait) 
00000c  bf00              NOP      
                  |L8.14|
00000e  f7fffffe          BL       get_systick
000012  1a80              SUBS     r0,r0,r2
000014  4298              CMP      r0,r3
000016  d3fa              BCC      |L8.14|
;;;394        { 
;;;395        } 
;;;396    
;;;397    }
000018  bd00              POP      {pc}
;;;398    
                          ENDP


                          AREA ||i.SysTick_enable||, CODE, READONLY, ALIGN=2

                  SysTick_enable PROC
;;;398    
;;;399    void SysTick_enable(int ticks_per_second)
000000  b570              PUSH     {r4-r6,lr}
;;;400    {
000002  4605              MOV      r5,r0
;;;401        set_systick(0);
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       set_systick
;;;402        if (SysTick_Config(SystemCoreClock / ticks_per_second))
00000a  4629              MOV      r1,r5
00000c  480f              LDR      r0,|L9.76|
00000e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000010  f7fffffe          BL       __aeabi_uidivmod
000014  4604              MOV      r4,r0
000016  1e60              SUBS     r0,r4,#1
000018  490d              LDR      r1,|L9.80|
00001a  4288              CMP      r0,r1
00001c  d901              BLS      |L9.34|
00001e  2001              MOVS     r0,#1
000020  e00c              B        |L9.60|
                  |L9.34|
000022  1e60              SUBS     r0,r4,#1
000024  490b              LDR      r1,|L9.84|
000026  6148              STR      r0,[r1,#0x14]
000028  2103              MOVS     r1,#3
00002a  1f08              SUBS     r0,r1,#4
00002c  f7fffffe          BL       NVIC_SetPriority
000030  2000              MOVS     r0,#0
000032  4908              LDR      r1,|L9.84|
000034  6188              STR      r0,[r1,#0x18]
000036  2007              MOVS     r0,#7
000038  6108              STR      r0,[r1,#0x10]
00003a  2000              MOVS     r0,#0
                  |L9.60|
00003c  2800              CMP      r0,#0
00003e  d004              BEQ      |L9.74|
;;;403        {
;;;404            /* Setup SysTick Timer for 1 second interrupts  */
;;;405            printf("Set system tick error!!\n");
000040  a005              ADR      r0,|L9.88|
000042  f7fffffe          BL       __2printf
;;;406            while (1);
000046  bf00              NOP      
                  |L9.72|
000048  e7fe              B        |L9.72|
                  |L9.74|
;;;407        }
;;;408    
;;;409        #if defined (ENABLE_TICK_EVENT)
;;;410        TickInitTickEvent();
;;;411        #endif
;;;412    }
00004a  bd70              POP      {r4-r6,pc}
;;;413    
                          ENDP

                  |L9.76|
                          DCD      SystemCoreClock
                  |L9.80|
                          DCD      0x00ffffff
                  |L9.84|
                          DCD      0xe000e000
                  |L9.88|
000058  53657420          DCB      "Set system tick error!!\n",0
00005c  73797374
000060  656d2074
000064  69636b20
000068  6572726f
00006c  7221210a
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.TIMER0_Init||, CODE, READONLY, ALIGN=2

                  TIMER0_Init PROC
;;;597    
;;;598    void TIMER0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;599    {
;;;600        TIMER_Open(TIMER0, TIMER_PERIODIC_MODE, 10);
000002  220a              MOVS     r2,#0xa
000004  2101              MOVS     r1,#1
000006  06c9              LSLS     r1,r1,#27
000008  4803              LDR      r0,|L10.24|
00000a  f7fffffe          BL       TIMER_Open
;;;601    
;;;602        NVIC_EnableIRQ(TMR0_IRQn);	
00000e  2008              MOVS     r0,#8
000010  f7fffffe          BL       NVIC_EnableIRQ
;;;603    }
000014  bd10              POP      {r4,pc}
;;;604    
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      0x40050000

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;625    
;;;626    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;627    {
;;;628        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  227d              MOVS     r2,#0x7d
000004  00d2              LSLS     r2,r2,#3
000006  2101              MOVS     r1,#1
000008  06c9              LSLS     r1,r1,#27
00000a  4806              LDR      r0,|L11.36|
00000c  f7fffffe          BL       TIMER_Open
;;;629        TIMER_EnableInt(TIMER1);
000010  4804              LDR      r0,|L11.36|
000012  f7fffffe          BL       TIMER_EnableInt
;;;630        NVIC_EnableIRQ(TMR1_IRQn);	
000016  2009              MOVS     r0,#9
000018  f7fffffe          BL       NVIC_EnableIRQ
;;;631        TIMER_Start(TIMER1);
00001c  4801              LDR      r0,|L11.36|
00001e  f7fffffe          BL       TIMER_Start
;;;632    }
000022  bd10              POP      {r4,pc}
;;;633    
                          ENDP

                  |L11.36|
                          DCD      0x40050020

                          AREA ||i.TIMER_EnableInt||, CODE, READONLY, ALIGN=1

                  TIMER_EnableInt PROC
;;;334      */
;;;335    static __INLINE void TIMER_EnableInt(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;336    {
;;;337        timer->CTL |= TIMER_CTL_INTEN_Msk;
000002  2201              MOVS     r2,#1
000004  0752              LSLS     r2,r2,#29
000006  4311              ORRS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;338    }
00000a  4770              BX       lr
;;;339    
                          ENDP


                          AREA ||i.TIMER_Start||, CODE, READONLY, ALIGN=1

                  TIMER_Start PROC
;;;172      */
;;;173    static __INLINE void TIMER_Start(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;174    {
;;;175        timer->CTL |= TIMER_CTL_CNTEN_Msk;
000002  2201              MOVS     r2,#1
000004  0792              LSLS     r2,r2,#30
000006  4311              ORRS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;176    }
00000a  4770              BX       lr
;;;177    
                          ENDP


                          AREA ||i.TMR0_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR0_IRQHandler PROC
;;;580    
;;;581    void TMR0_IRQHandler(void)
000000  b500              PUSH     {lr}
;;;582    {	
;;;583        if(TIMER_GetIntFlag(TIMER0) == 1)
000002  bf00              NOP      
000004  4811              LDR      r0,|L14.76|
000006  6880              LDR      r0,[r0,#8]
000008  07c0              LSLS     r0,r0,#31
00000a  0fc0              LSRS     r0,r0,#31
00000c  2800              CMP      r0,#0
00000e  d01b              BEQ      |L14.72|
;;;584        {
;;;585            u32rcvtick++;
000010  480f              LDR      r0,|L14.80|
000012  6800              LDR      r0,[r0,#0]  ; u32rcvtick
000014  1c40              ADDS     r0,r0,#1
000016  490e              LDR      r1,|L14.80|
000018  6008              STR      r0,[r1,#0]  ; u32rcvtick
;;;586            
;;;587    		if (u32rcvtick == 1000)
00001a  4608              MOV      r0,r1
00001c  6800              LDR      r0,[r0,#0]  ; u32rcvtick
00001e  217d              MOVS     r1,#0x7d
000020  00c9              LSLS     r1,r1,#3
000022  4288              CMP      r0,r1
000024  d10a              BNE      |L14.60|
;;;588    		{
;;;589                u32rcvtick = 0;
000026  2000              MOVS     r0,#0
000028  4909              LDR      r1,|L14.80|
00002a  6008              STR      r0,[r1,#0]  ; u32rcvtick
;;;590                set_flag(flag_uart_rx_rcv_timeout_10000ms ,ENABLE);
00002c  4809              LDR      r0,|L14.84|
00002e  6800              LDR      r0,[r0,#0]  ; BitFlag
000030  2104              MOVS     r1,#4
000032  4308              ORRS     r0,r0,r1
000034  4907              LDR      r1,|L14.84|
000036  6008              STR      r0,[r1,#0]  ; BitFlag
;;;591                stop_timer0();
000038  f7fffffe          BL       stop_timer0
                  |L14.60|
;;;592    		}   
;;;593    
;;;594    		set_flag(flag_uart_rx_rcv_ready ,DISABLE); 
00003c  4805              LDR      r0,|L14.84|
00003e  6800              LDR      r0,[r0,#0]  ; BitFlag
000040  2108              MOVS     r1,#8
000042  4388              BICS     r0,r0,r1
000044  4903              LDR      r1,|L14.84|
000046  6008              STR      r0,[r1,#0]  ; BitFlag
                  |L14.72|
;;;595        }
;;;596    }
000048  bd00              POP      {pc}
;;;597    
                          ENDP

00004a  0000              DCW      0x0000
                  |L14.76|
                          DCD      0x40050000
                  |L14.80|
                          DCD      u32rcvtick
                  |L14.84|
                          DCD      BitFlag

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;604    
;;;605    void TMR1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;606    {
;;;607    	
;;;608        if(TIMER_GetIntFlag(TIMER1) == 1)
000002  bf00              NOP      
000004  480f              LDR      r0,|L15.68|
000006  6880              LDR      r0,[r0,#8]
000008  07c0              LSLS     r0,r0,#31
00000a  0fc0              LSRS     r0,r0,#31
00000c  2800              CMP      r0,#0
00000e  d017              BEQ      |L15.64|
;;;609        {
;;;610            TIMER_ClearIntFlag(TIMER1);
000010  bf00              NOP      
000012  2001              MOVS     r0,#1
000014  490b              LDR      r1,|L15.68|
000016  6088              STR      r0,[r1,#8]
000018  bf00              NOP      
;;;611    		tick_counter();
00001a  f7fffffe          BL       tick_counter
;;;612    
;;;613    
;;;614    		if ((get_tick() % 1000) == 0)
00001e  f7fffffe          BL       get_tick
000022  4604              MOV      r4,r0
000024  217d              MOVS     r1,#0x7d
000026  00c9              LSLS     r1,r1,#3
000028  f7fffffe          BL       __aeabi_uidivmod
00002c  2900              CMP      r1,#0
00002e  d105              BNE      |L15.60|
;;;615    		{
;;;616                set_flag(flag_timer_period_1000ms ,ENABLE);
000030  4805              LDR      r0,|L15.72|
000032  6800              LDR      r0,[r0,#0]  ; BitFlag
000034  2102              MOVS     r1,#2
000036  4308              ORRS     r0,r0,r1
000038  4903              LDR      r1,|L15.72|
00003a  6008              STR      r0,[r1,#0]  ; BitFlag
                  |L15.60|
;;;617    		}          
;;;618    
;;;619    		if ((get_tick() % 50) == 0)
00003c  f7fffffe          BL       get_tick
                  |L15.64|
;;;620    		{
;;;621                
;;;622    		}	
;;;623        }
;;;624    }
000040  bd10              POP      {r4,pc}
;;;625    
                          ENDP

000042  0000              DCW      0x0000
                  |L15.68|
                          DCD      0x40050020
                  |L15.72|
                          DCD      BitFlag

                          AREA ||i.UART02_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART02_IRQHandler PROC
;;;738    
;;;739    void UART02_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;740    {
;;;741        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk | UART_INTSTS_RXTOINT_Msk))     /* UART receive data available flag */
000002  4811              LDR      r0,|L16.72|
000004  69c0              LDR      r0,[r0,#0x1c]
000006  2111              MOVS     r1,#0x11
000008  0209              LSLS     r1,r1,#8
00000a  4008              ANDS     r0,r0,r1
00000c  2800              CMP      r0,#0
00000e  d001              BEQ      |L16.20|
000010  2001              MOVS     r0,#1
000012  e000              B        |L16.22|
                  |L16.20|
000014  2000              MOVS     r0,#0
                  |L16.22|
000016  2800              CMP      r0,#0
000018  d009              BEQ      |L16.46|
;;;742        {
;;;743            while(UART_GET_RX_EMPTY(UART0) == 0)
00001a  e001              B        |L16.32|
                  |L16.28|
;;;744            {
;;;745    			UARTx_Process();
00001c  f7fffffe          BL       UARTx_Process
                  |L16.32|
000020  4809              LDR      r0,|L16.72|
000022  6980              LDR      r0,[r0,#0x18]         ;743
000024  2101              MOVS     r1,#1                 ;743
000026  0389              LSLS     r1,r1,#14             ;743
000028  4008              ANDS     r0,r0,r1              ;743
00002a  2800              CMP      r0,#0                 ;743
00002c  d0f6              BEQ      |L16.28|
                  |L16.46|
;;;746            }
;;;747        }
;;;748    
;;;749        if(UART0->FIFOSTS & (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))
00002e  4806              LDR      r0,|L16.72|
000030  6980              LDR      r0,[r0,#0x18]
000032  2171              MOVS     r1,#0x71
000034  4008              ANDS     r0,r0,r1
000036  2800              CMP      r0,#0
000038  d004              BEQ      |L16.68|
;;;750        {
;;;751            UART_ClearIntFlag(UART0, (UART_INTSTS_RLSINT_Msk| UART_INTSTS_BUFERRINT_Msk));
00003a  2109              MOVS     r1,#9
00003c  0289              LSLS     r1,r1,#10
00003e  4802              LDR      r0,|L16.72|
000040  f7fffffe          BL       UART_ClearIntFlag
                  |L16.68|
;;;752        }	
;;;753    }
000044  bd10              POP      {r4,pc}
;;;754    
                          ENDP

000046  0000              DCW      0x0000
                  |L16.72|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;754    
;;;755    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;756    {
;;;757        SYS_ResetModule(UART0_RST);
000002  4819              LDR      r0,|L17.104|
000004  f7fffffe          BL       SYS_ResetModule
;;;758    
;;;759        /* Configure UART0 and set UART0 baud rate */
;;;760        UART_Open(UART0, 115200);
000008  21e1              MOVS     r1,#0xe1
00000a  0249              LSLS     r1,r1,#9
00000c  4817              LDR      r0,|L17.108|
00000e  f7fffffe          BL       UART_Open
;;;761        UART_EnableInt(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
000012  2111              MOVS     r1,#0x11
000014  4815              LDR      r0,|L17.108|
000016  f7fffffe          BL       UART_EnableInt
;;;762        NVIC_EnableIRQ(UART02_IRQn);
00001a  200c              MOVS     r0,#0xc
00001c  f7fffffe          BL       NVIC_EnableIRQ
;;;763    	
;;;764    	#if (_debug_log_UART_ == 1)	//debug
;;;765    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000020  f7fffffe          BL       CLK_GetCPUFreq
000024  4604              MOV      r4,r0
000026  4621              MOV      r1,r4
000028  a011              ADR      r0,|L17.112|
00002a  f7fffffe          BL       __2printf
;;;766    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
00002e  f7fffffe          BL       CLK_GetHXTFreq
000032  4604              MOV      r4,r0
000034  4621              MOV      r1,r4
000036  a015              ADR      r0,|L17.140|
000038  f7fffffe          BL       __2printf
;;;767    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
00003c  f7fffffe          BL       CLK_GetLXTFreq
000040  4604              MOV      r4,r0
000042  4621              MOV      r1,r4
000044  a017              ADR      r0,|L17.164|
000046  f7fffffe          BL       __2printf
;;;768    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
00004a  f7fffffe          BL       CLK_GetPCLK0Freq
00004e  4604              MOV      r4,r0
000050  4621              MOV      r1,r4
000052  a01a              ADR      r0,|L17.188|
000054  f7fffffe          BL       __2printf
;;;769    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
000058  f7fffffe          BL       CLK_GetPCLK1Freq
00005c  4604              MOV      r4,r0
00005e  4621              MOV      r1,r4
000060  a01d              ADR      r0,|L17.216|
000062  f7fffffe          BL       __2printf
;;;770    	#endif	
;;;771    
;;;772    }
000066  bd10              POP      {r4,pc}
;;;773    
                          ENDP

                  |L17.104|
                          DCD      0x04000010
                  |L17.108|
                          DCD      0x40070000
                  |L17.112|
000070  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000074  4b5f4765
000078  74435055
00007c  46726571
000080  203a2025
000084  38640d0a
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L17.140|
00008c  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
000090  47657448
000094  58544672
000098  6571203a
00009c  20253864
0000a0  0d0a00  
0000a3  00                DCB      0
                  |L17.164|
0000a4  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000a8  4765744c
0000ac  58544672
0000b0  6571203a
0000b4  20253864
0000b8  0d0a00  
0000bb  00                DCB      0
                  |L17.188|
0000bc  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000c0  47657450
0000c4  434c4b30
0000c8  46726571
0000cc  203a2025
0000d0  38640d0a
0000d4  00      
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L17.216|
0000d8  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000dc  47657450
0000e0  434c4b31
0000e4  46726571
0000e8  203a2025
0000ec  38640d0a
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                  UARTx_Process PROC
;;;708    
;;;709    void UARTx_Process(void)
000000  b510              PUSH     {r4,lr}
;;;710    {
;;;711    	uint8_t res = 0;
000002  2400              MOVS     r4,#0
;;;712    	res = UART_READ(UART0);
000004  4803              LDR      r0,|L18.20|
000006  6800              LDR      r0,[r0,#0]
000008  b2c4              UXTB     r4,r0
;;;713    
;;;714        #if 1
;;;715        rx_rcv_irq(res);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       rx_rcv_irq
;;;716        #else
;;;717    	if (res > 0x7F)
;;;718    	{
;;;719    		printf("invalid command\r\n");
;;;720    	}
;;;721    	else
;;;722    	{
;;;723    		switch(res)
;;;724    		{
;;;725    			case '1':
;;;726    				break;
;;;727    
;;;728    			case 'X':
;;;729    			case 'x':
;;;730    			case 'Z':
;;;731    			case 'z':
;;;732    				NVIC_SystemReset();		
;;;733    				break;
;;;734    		}
;;;735    	}
;;;736        #endif
;;;737    }
000010  bd10              POP      {r4,pc}
;;;738    
                          ENDP

000012  0000              DCW      0x0000
                  |L18.20|
                          DCD      0x40070000

                          AREA ||i.compare_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  compare_buffer PROC
;;;166    
;;;167    void compare_buffer(uint8_t *src, uint8_t *des, int nBytes)
000000  b5f8              PUSH     {r3-r7,lr}
;;;168    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;169        uint16_t i = 0;	
000008  2400              MOVS     r4,#0
;;;170    	
;;;171        #if 1
;;;172        for (i = 0; i < nBytes; i++)
00000a  bf00              NOP      
00000c  e011              B        |L19.50|
                  |L19.14|
;;;173        {
;;;174            if (src[i] != des[i])
00000e  5d28              LDRB     r0,[r5,r4]
000010  5d31              LDRB     r1,[r6,r4]
000012  4288              CMP      r0,r1
000014  d00b              BEQ      |L19.46|
;;;175            {
;;;176                printf("error idx : %4d : 0x%2X , 0x%2X\r\n", i , src[i],des[i]);
000016  5d33              LDRB     r3,[r6,r4]
000018  5d2a              LDRB     r2,[r5,r4]
00001a  4621              MOV      r1,r4
00001c  a00f              ADR      r0,|L19.92|
00001e  f7fffffe          BL       __2printf
;;;177    			set_flag(flag_error , ENABLE);
000022  4817              LDR      r0,|L19.128|
000024  6800              LDR      r0,[r0,#0]  ; BitFlag
000026  2120              MOVS     r1,#0x20
000028  4308              ORRS     r0,r0,r1
00002a  4915              LDR      r1,|L19.128|
00002c  6008              STR      r0,[r1,#0]  ; BitFlag
                  |L19.46|
00002e  1c60              ADDS     r0,r4,#1              ;172
000030  b284              UXTH     r4,r0                 ;172
                  |L19.50|
000032  42bc              CMP      r4,r7                 ;172
000034  dbeb              BLT      |L19.14|
;;;178            }
;;;179        }
;;;180    
;;;181    	if (!is_flag_set(flag_error))
000036  4812              LDR      r0,|L19.128|
000038  6800              LDR      r0,[r0,#0]  ; BitFlag
00003a  2120              MOVS     r1,#0x20
00003c  4008              ANDS     r0,r0,r1
00003e  0940              LSRS     r0,r0,#5
000040  2800              CMP      r0,#0
000042  d109              BNE      |L19.88|
;;;182    	{
;;;183        	printf("%s finish \r\n" , __FUNCTION__);	
000044  490f              LDR      r1,|L19.132|
000046  a010              ADR      r0,|L19.136|
000048  f7fffffe          BL       __2printf
;;;184    		set_flag(flag_error , DISABLE);
00004c  480c              LDR      r0,|L19.128|
00004e  6800              LDR      r0,[r0,#0]  ; BitFlag
000050  2120              MOVS     r1,#0x20
000052  4388              BICS     r0,r0,r1
000054  490a              LDR      r1,|L19.128|
000056  6008              STR      r0,[r1,#0]  ; BitFlag
                  |L19.88|
;;;185    	}
;;;186        #else
;;;187        if (memcmp(src, des, nBytes))
;;;188        {
;;;189            printf("\nMismatch!! - %d\n", nBytes);
;;;190            for (i = 0; i < nBytes; i++)
;;;191                printf("0x%02x    0x%02x\n", src[i], des[i]);
;;;192            return -1;
;;;193        }
;;;194        #endif
;;;195    
;;;196    }
000058  bdf8              POP      {r3-r7,pc}
;;;197    
                          ENDP

00005a  0000              DCW      0x0000
                  |L19.92|
00005c  6572726f          DCB      "error idx : %4d : 0x%2X , 0x%2X\r\n",0
000060  72206964
000064  78203a20
000068  25346420
00006c  3a203078
000070  25325820
000074  2c203078
000078  2532580d
00007c  0a00    
00007e  00                DCB      0
00007f  00                DCB      0
                  |L19.128|
                          DCD      BitFlag
                  |L19.132|
                          DCD      __FUNCTION__
                  |L19.136|
000088  25732066          DCB      "%s finish \r\n",0
00008c  696e6973
000090  68200d0a
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0

                          AREA ||i.copy_buffer||, CODE, READONLY, ALIGN=1

                  copy_buffer PROC
;;;213    
;;;214    void copy_buffer(void *dest, void *src, unsigned int size)
000000  b570              PUSH     {r4-r6,lr}
;;;215    {
000002  4603              MOV      r3,r0
;;;216        uint8_t *pu8Src, *pu8Dest;
;;;217        unsigned int i;
;;;218        
;;;219        pu8Dest = (uint8_t *)dest;
000004  461d              MOV      r5,r3
;;;220        pu8Src  = (uint8_t *)src;
000006  460c              MOV      r4,r1
;;;221    
;;;222    
;;;223    	#if 0
;;;224    	  while (size--)
;;;225    	    *pu8Dest++ = *pu8Src++;
;;;226    	#else
;;;227        for (i = 0; i < size; i++)
000008  2000              MOVS     r0,#0
00000a  e002              B        |L20.18|
                  |L20.12|
;;;228            pu8Dest[i] = pu8Src[i];
00000c  5c26              LDRB     r6,[r4,r0]
00000e  542e              STRB     r6,[r5,r0]
000010  1c40              ADDS     r0,r0,#1              ;227
                  |L20.18|
000012  4290              CMP      r0,r2                 ;227
000014  d3fa              BCC      |L20.12|
;;;229    	#endif
;;;230    }
000016  bd70              POP      {r4-r6,pc}
;;;231    
                          ENDP


                          AREA ||i.dump_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  dump_buffer PROC
;;;231    
;;;232    void dump_buffer(uint8_t *pucBuff, int nBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;233    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;234        uint16_t i = 0;
000006  2400              MOVS     r4,#0
;;;235        
;;;236        printf("dump_buffer : %2d\r\n" , nBytes);    
000008  4631              MOV      r1,r6
00000a  a00e              ADR      r0,|L21.68|
00000c  f7fffffe          BL       __2printf
;;;237        for (i = 0 ; i < nBytes ; i++)
000010  bf00              NOP      
000012  e010              B        |L21.54|
                  |L21.20|
;;;238        {
;;;239            printf("0x%2X," , pucBuff[i]);
000014  5d29              LDRB     r1,[r5,r4]
000016  a010              ADR      r0,|L21.88|
000018  f7fffffe          BL       __2printf
;;;240            if ((i+1)%8 ==0)
00001c  1c60              ADDS     r0,r4,#1
00001e  17c1              ASRS     r1,r0,#31
000020  0f49              LSRS     r1,r1,#29
000022  1809              ADDS     r1,r1,r0
000024  10c9              ASRS     r1,r1,#3
000026  00c9              LSLS     r1,r1,#3
000028  1a41              SUBS     r1,r0,r1
00002a  d102              BNE      |L21.50|
;;;241            {
;;;242                printf("\r\n");
00002c  a00c              ADR      r0,|L21.96|
00002e  f7fffffe          BL       __2printf
                  |L21.50|
000032  1c60              ADDS     r0,r4,#1              ;237
000034  b284              UXTH     r4,r0                 ;237
                  |L21.54|
000036  42b4              CMP      r4,r6                 ;237
000038  dbec              BLT      |L21.20|
;;;243            }            
;;;244        }
;;;245        printf("\r\n\r\n");
00003a  a00a              ADR      r0,|L21.100|
00003c  f7fffffe          BL       __2printf
;;;246    }
000040  bd70              POP      {r4-r6,pc}
;;;247    
                          ENDP

000042  0000              DCW      0x0000
                  |L21.68|
000044  64756d70          DCB      "dump_buffer : %2d\r\n",0
000048  5f627566
00004c  66657220
000050  3a202532
000054  640d0a00
                  |L21.88|
000058  30782532          DCB      "0x%2X,",0
00005c  582c00  
00005f  00                DCB      0
                  |L21.96|
000060  0d0a00            DCB      "\r\n",0
000063  00                DCB      0
                  |L21.100|
000064  0d0a0d0a          DCB      "\r\n\r\n",0
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.dump_buffer_hex||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  dump_buffer_hex PROC
;;;247    
;;;248    void dump_buffer_hex(uint8_t *pucBuff, int nBytes)
000000  b5f8              PUSH     {r3-r7,lr}
;;;249    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;250        int     nIdx, i;
;;;251    
;;;252        nIdx = 0;
000006  2500              MOVS     r5,#0
;;;253        while (nBytes > 0)
000008  e02b              B        |L22.98|
                  |L22.10|
;;;254        {
;;;255            printf("0x%04X  ", nIdx);
00000a  4629              MOV      r1,r5
00000c  a018              ADR      r0,|L22.112|
00000e  f7fffffe          BL       __2printf
;;;256            for (i = 0; i < 16; i++)
000012  2400              MOVS     r4,#0
000014  e005              B        |L22.34|
                  |L22.22|
;;;257                printf("%02X ", pucBuff[nIdx + i]);
000016  1928              ADDS     r0,r5,r4
000018  5c31              LDRB     r1,[r6,r0]
00001a  a018              ADR      r0,|L22.124|
00001c  f7fffffe          BL       __2printf
000020  1c64              ADDS     r4,r4,#1              ;256
                  |L22.34|
000022  2c10              CMP      r4,#0x10              ;256
000024  dbf7              BLT      |L22.22|
;;;258            printf("  ");
000026  a017              ADR      r0,|L22.132|
000028  f7fffffe          BL       __2printf
;;;259            for (i = 0; i < 16; i++)
00002c  2400              MOVS     r4,#0
00002e  e012              B        |L22.86|
                  |L22.48|
;;;260            {
;;;261                if ((pucBuff[nIdx + i] >= 0x20) && (pucBuff[nIdx + i] < 127))
000030  1928              ADDS     r0,r5,r4
000032  5c30              LDRB     r0,[r6,r0]
000034  2820              CMP      r0,#0x20
000036  db09              BLT      |L22.76|
000038  1928              ADDS     r0,r5,r4
00003a  5c30              LDRB     r0,[r6,r0]
00003c  287f              CMP      r0,#0x7f
00003e  da05              BGE      |L22.76|
;;;262                    printf("%c", pucBuff[nIdx + i]);
000040  1928              ADDS     r0,r5,r4
000042  5c31              LDRB     r1,[r6,r0]
000044  a010              ADR      r0,|L22.136|
000046  f7fffffe          BL       __2printf
00004a  e002              B        |L22.82|
                  |L22.76|
;;;263                else
;;;264                    printf(".");
00004c  a00f              ADR      r0,|L22.140|
00004e  f7fffffe          BL       __2printf
                  |L22.82|
;;;265                nBytes--;
000052  1e7f              SUBS     r7,r7,#1
000054  1c64              ADDS     r4,r4,#1              ;259
                  |L22.86|
000056  2c10              CMP      r4,#0x10              ;259
000058  dbea              BLT      |L22.48|
;;;266            }
;;;267            nIdx += 16;
00005a  3510              ADDS     r5,r5,#0x10
;;;268            printf("\n");
00005c  a00c              ADR      r0,|L22.144|
00005e  f7fffffe          BL       __2printf
                  |L22.98|
000062  2f00              CMP      r7,#0                 ;253
000064  dcd1              BGT      |L22.10|
;;;269        }
;;;270        printf("\n");
000066  a00a              ADR      r0,|L22.144|
000068  f7fffffe          BL       __2printf
;;;271    }
00006c  bdf8              POP      {r3-r7,pc}
;;;272    
                          ENDP

00006e  0000              DCW      0x0000
                  |L22.112|
000070  30782530          DCB      "0x%04X  ",0
000074  34582020
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L22.124|
00007c  25303258          DCB      "%02X ",0
000080  2000    
000082  00                DCB      0
000083  00                DCB      0
                  |L22.132|
000084  202000            DCB      "  ",0
000087  00                DCB      0
                  |L22.136|
000088  256300            DCB      "%c",0
00008b  00                DCB      0
                  |L22.140|
00008c  2e00              DCB      ".",0
00008e  00                DCB      0
00008f  00                DCB      0
                  |L22.144|
000090  0a00              DCB      "\n",0
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i.fmt_err||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  fmt_err PROC
;;;456    
;;;457    void fmt_err(uint8_t idx)
000000  b570              PUSH     {r4-r6,lr}
;;;458    {
000002  4605              MOV      r5,r0
;;;459        uint8_t i = 0;
000004  2400              MOVS     r4,#0
;;;460    
;;;461        printf("cmd parsing error(0x%2X)\r\n",idx);
000006  4629              MOV      r1,r5
000008  a018              ADR      r0,|L23.108|
00000a  f7fffffe          BL       __2printf
;;;462        put_rc(idx);
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       put_rc
;;;463        for(i = 0 ; i <= (UART_RX_RCV_LEN-1) ; i++)
000014  bf00              NOP      
000016  e00f              B        |L23.56|
                  |L23.24|
;;;464        {
;;;465            printf("(%d):0x%2X",i , RXBUFFER[i]);
000018  481b              LDR      r0,|L23.136|
00001a  5d02              LDRB     r2,[r0,r4]
00001c  4621              MOV      r1,r4
00001e  a01b              ADR      r0,|L23.140|
000020  f7fffffe          BL       __2printf
;;;466            if (i == idx)
000024  42ac              CMP      r4,r5
000026  d102              BNE      |L23.46|
;;;467            {
;;;468                printf("   ***");
000028  a01b              ADR      r0,|L23.152|
00002a  f7fffffe          BL       __2printf
                  |L23.46|
;;;469            }
;;;470            printf("\r\n");
00002e  a015              ADR      r0,|L23.132|
000030  f7fffffe          BL       __2printf
000034  1c60              ADDS     r0,r4,#1              ;463
000036  b2c4              UXTB     r4,r0                 ;463
                  |L23.56|
000038  2c07              CMP      r4,#7                 ;463
00003a  dded              BLE      |L23.24|
;;;471            // if ((i+1)%8 ==0)
;;;472            // {
;;;473            //     printf("\r\n");
;;;474            // }            
;;;475        }
;;;476        printf("\r\n\r\n");
00003c  a018              ADR      r0,|L23.160|
00003e  f7fffffe          BL       __2printf
;;;477    
;;;478        uart_rcv_cnt = 0;
000042  2000              MOVS     r0,#0
000044  4918              LDR      r1,|L23.168|
000046  7008              STRB     r0,[r1,#0]
;;;479        set_flag(flag_uart_rx_rcv_timeout_10000ms ,DISABLE);
000048  4818              LDR      r0,|L23.172|
00004a  6800              LDR      r0,[r0,#0]  ; BitFlag
00004c  2104              MOVS     r1,#4
00004e  4388              BICS     r0,r0,r1
000050  4916              LDR      r1,|L23.172|
000052  6008              STR      r0,[r1,#0]  ; BitFlag
;;;480        stop_timer0();
000054  f7fffffe          BL       stop_timer0
;;;481    
;;;482        for(i = 0 ; i <= (UART_RX_RCV_LEN-1) ; i++)
000058  2400              MOVS     r4,#0
00005a  e004              B        |L23.102|
                  |L23.92|
;;;483        {
;;;484            RXBUFFER[i] = 0x00;
00005c  2000              MOVS     r0,#0
00005e  490a              LDR      r1,|L23.136|
000060  5508              STRB     r0,[r1,r4]
000062  1c60              ADDS     r0,r4,#1              ;482
000064  b2c4              UXTB     r4,r0                 ;482
                  |L23.102|
000066  2c07              CMP      r4,#7                 ;482
000068  ddf8              BLE      |L23.92|
;;;485        }
;;;486    }
00006a  bd70              POP      {r4-r6,pc}
;;;487    
                          ENDP

                  |L23.108|
00006c  636d6420          DCB      "cmd parsing error(0x%2X)"
000070  70617273
000074  696e6720
000078  6572726f
00007c  72283078
000080  25325829
                  |L23.132|
000084  0d0a00            DCB      "\r\n",0
000087  00                DCB      0
                  |L23.136|
                          DCD      RXBUFFER
                  |L23.140|
00008c  28256429          DCB      "(%d):0x%2X",0
000090  3a307825
000094  325800  
000097  00                DCB      0
                  |L23.152|
000098  2020202a          DCB      "   ***",0
00009c  2a2a00  
00009f  00                DCB      0
                  |L23.160|
0000a0  0d0a0d0a          DCB      "\r\n\r\n",0
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L23.168|
                          DCD      uart_rcv_cnt
                  |L23.172|
                          DCD      BitFlag

                          AREA ||i.fmt_parsing||, CODE, READONLY, ALIGN=2

                  fmt_parsing PROC
;;;487    
;;;488    void fmt_parsing(void)
000000  b510              PUSH     {r4,lr}
;;;489    {
;;;490        uint8_t cal = 0;
000002  2400              MOVS     r4,#0
;;;491    
;;;492        if (is_flag_set(flag_uart_rx_rcv_ready))                        //Uart receives completion and starts parsing.
000004  4825              LDR      r0,|L24.156|
000006  6800              LDR      r0,[r0,#0]  ; BitFlag
000008  2108              MOVS     r1,#8
00000a  4008              ANDS     r0,r0,r1
00000c  08c0              LSRS     r0,r0,#3
00000e  2800              CMP      r0,#0
000010  d043              BEQ      |L24.154|
;;;493        {
;;;494            if (RXBUFFER[fmt_head] != UART_CMD_FMT_HEAD )               //Input format parsing. check header
000012  4823              LDR      r0,|L24.160|
000014  7800              LDRB     r0,[r0,#0]  ; RXBUFFER
000016  285a              CMP      r0,#0x5a
000018  d003              BEQ      |L24.34|
;;;495            {
;;;496                fmt_err(error_head);
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       fmt_err
000020  e035              B        |L24.142|
                  |L24.34|
;;;497            }
;;;498            else
;;;499            {
;;;500                cal = CRC8(RXBUFFER, (UART_RX_RCV_LEN - 2 ));
000022  2106              MOVS     r1,#6
000024  481e              LDR      r0,|L24.160|
000026  f7fffffe          BL       CRC8
00002a  4604              MOV      r4,r0
;;;501                if (RXBUFFER[fmt_cs] != cal)                            //Input format parsing. check checksum
00002c  481c              LDR      r0,|L24.160|
00002e  7980              LDRB     r0,[r0,#6]  ; RXBUFFER
000030  42a0              CMP      r0,r4
000032  d003              BEQ      |L24.60|
;;;502                {
;;;503                   fmt_err(error_cs);  
000034  2006              MOVS     r0,#6
000036  f7fffffe          BL       fmt_err
00003a  e028              B        |L24.142|
                  |L24.60|
;;;504                }
;;;505                else 
;;;506                {
;;;507                    if (RXBUFFER[fmt_tail] != UART_CMD_FMT_TAIL)        //Input format parsing. check tail
00003c  4818              LDR      r0,|L24.160|
00003e  79c0              LDRB     r0,[r0,#7]  ; RXBUFFER
000040  28a5              CMP      r0,#0xa5
000042  d003              BEQ      |L24.76|
;;;508                    {
;;;509                        fmt_err(error_tail);
000044  2007              MOVS     r0,#7
000046  f7fffffe          BL       fmt_err
00004a  e020              B        |L24.142|
                  |L24.76|
;;;510                    }
;;;511                    else
;;;512                    {
;;;513                        if ((RXBUFFER[fmt_code] == UART_CMD_FMT_CODE1) || 
00004c  4814              LDR      r0,|L24.160|
00004e  7840              LDRB     r0,[r0,#1]  ; RXBUFFER
000050  2801              CMP      r0,#1
000052  d00b              BEQ      |L24.108|
;;;514                            (RXBUFFER[fmt_code] == UART_CMD_FMT_CODE2) || 
000054  4812              LDR      r0,|L24.160|
000056  7840              LDRB     r0,[r0,#1]  ; RXBUFFER
000058  2802              CMP      r0,#2
00005a  d007              BEQ      |L24.108|
;;;515                            (RXBUFFER[fmt_code] == UART_CMD_FMT_CODE3) ||
00005c  4810              LDR      r0,|L24.160|
00005e  7840              LDRB     r0,[r0,#1]  ; RXBUFFER
000060  2803              CMP      r0,#3
000062  d003              BEQ      |L24.108|
;;;516                            (RXBUFFER[fmt_code] == UART_CMD_FMT_CODE4) )
000064  480e              LDR      r0,|L24.160|
000066  7840              LDRB     r0,[r0,#1]  ; RXBUFFER
000068  2804              CMP      r0,#4
00006a  d10d              BNE      |L24.136|
                  |L24.108|
;;;517                        {
;;;518                            set_flag(flag_uart_rx_rcv_timeout_10000ms ,DISABLE);
00006c  480b              LDR      r0,|L24.156|
00006e  6800              LDR      r0,[r0,#0]  ; BitFlag
000070  2104              MOVS     r1,#4
000072  4388              BICS     r0,r0,r1
000074  4909              LDR      r1,|L24.156|
000076  6008              STR      r0,[r1,#0]  ; BitFlag
;;;519    
;;;520                            printf("process OK !\r\n");
000078  a00a              ADR      r0,|L24.164|
00007a  f7fffffe          BL       __2printf
;;;521    
;;;522                            dump_buffer(RXBUFFER , UART_RX_RCV_LEN);
00007e  2108              MOVS     r1,#8
000080  4807              LDR      r0,|L24.160|
000082  f7fffffe          BL       dump_buffer
000086  e002              B        |L24.142|
                  |L24.136|
;;;523                        }
;;;524                        else
;;;525                        {
;;;526                            fmt_err(error_wrong_code);
000088  2001              MOVS     r0,#1
00008a  f7fffffe          BL       fmt_err
                  |L24.142|
;;;527                        }                        
;;;528                    }
;;;529                }
;;;530            }         
;;;531    
;;;532            set_flag(flag_uart_rx_rcv_ready ,DISABLE); 
00008e  4803              LDR      r0,|L24.156|
000090  6800              LDR      r0,[r0,#0]  ; BitFlag
000092  2108              MOVS     r1,#8
000094  4388              BICS     r0,r0,r1
000096  4901              LDR      r1,|L24.156|
000098  6008              STR      r0,[r1,#0]  ; BitFlag
                  |L24.154|
;;;533        }
;;;534    }
00009a  bd10              POP      {r4,pc}
;;;535    
                          ENDP

                  |L24.156|
                          DCD      BitFlag
                  |L24.160|
                          DCD      RXBUFFER
                  |L24.164|
0000a4  70726f63          DCB      "process OK !\r\n",0
0000a8  65737320
0000ac  4f4b2021
0000b0  0d0a00  
0000b3  00                DCB      0

                          AREA ||i.get_systick||, CODE, READONLY, ALIGN=2

                  get_systick PROC
;;;132    
;;;133    uint32_t get_systick(void)
000000  4801              LDR      r0,|L25.8|
;;;134    {
;;;135    	return (counter_systick);
000002  6800              LDR      r0,[r0,#0]  ; counter_systick
;;;136    }
000004  4770              BX       lr
;;;137    
                          ENDP

000006  0000              DCW      0x0000
                  |L25.8|
                          DCD      counter_systick

                          AREA ||i.get_tick||, CODE, READONLY, ALIGN=2

                  get_tick PROC
;;;147    
;;;148    uint32_t get_tick(void)
000000  4801              LDR      r0,|L26.8|
;;;149    {
;;;150    	return (counter_tick);
000002  6800              LDR      r0,[r0,#0]  ; counter_tick
;;;151    }
000004  4770              BX       lr
;;;152    
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      counter_tick

                          AREA ||i.loop||, CODE, READONLY, ALIGN=2

                  loop PROC
;;;681    
;;;682    void loop(void)
000000  b510              PUSH     {r4,lr}
;;;683    {
;;;684    	// static uint32_t LOG1 = 0;
;;;685    	// static uint32_t LOG2 = 0;
;;;686    
;;;687        if ((get_systick() % 1000) == 0)
000002  f7fffffe          BL       get_systick
;;;688        {
;;;689            // printf("%s(systick) : %4d\r\n",__FUNCTION__,LOG2++);    
;;;690        }
;;;691    
;;;692        if (is_flag_set(flag_uart_rx_rcv_timeout_10000ms))
000006  4812              LDR      r0,|L27.80|
000008  6800              LDR      r0,[r0,#0]  ; BitFlag
00000a  2104              MOVS     r1,#4
00000c  4008              ANDS     r0,r0,r1
00000e  0880              LSRS     r0,r0,#2
000010  2800              CMP      r0,#0
000012  d007              BEQ      |L27.36|
;;;693        {
;;;694            set_flag(flag_uart_rx_rcv_timeout_10000ms ,DISABLE);
000014  480e              LDR      r0,|L27.80|
000016  6800              LDR      r0,[r0,#0]  ; BitFlag
000018  4388              BICS     r0,r0,r1
00001a  490d              LDR      r1,|L27.80|
00001c  6008              STR      r0,[r1,#0]  ; BitFlag
;;;695            fmt_err(error_timeout);     
00001e  2008              MOVS     r0,#8
000020  f7fffffe          BL       fmt_err
                  |L27.36|
;;;696        }
;;;697    
;;;698        fmt_parsing();
000024  f7fffffe          BL       fmt_parsing
;;;699    
;;;700        if (is_flag_set(flag_timer_period_1000ms))
000028  4809              LDR      r0,|L27.80|
00002a  6800              LDR      r0,[r0,#0]  ; BitFlag
00002c  2102              MOVS     r1,#2
00002e  4008              ANDS     r0,r0,r1
000030  0840              LSRS     r0,r0,#1
000032  2800              CMP      r0,#0
000034  d00a              BEQ      |L27.76|
;;;701        {
;;;702            set_flag(flag_timer_period_1000ms ,DISABLE);
000036  4806              LDR      r0,|L27.80|
000038  6800              LDR      r0,[r0,#0]  ; BitFlag
00003a  4388              BICS     r0,r0,r1
00003c  4904              LDR      r1,|L27.80|
00003e  6008              STR      r0,[r1,#0]  ; BitFlag
;;;703    
;;;704            // printf("%s(timer) : %4d\r\n",__FUNCTION__,LOG1++);
;;;705            PB14 ^= 1;        
000040  4804              LDR      r0,|L27.84|
000042  6b80              LDR      r0,[r0,#0x38]
000044  2101              MOVS     r1,#1
000046  4048              EORS     r0,r0,r1
000048  4902              LDR      r1,|L27.84|
00004a  6388              STR      r0,[r1,#0x38]
                  |L27.76|
;;;706        }
;;;707    }
00004c  bd10              POP      {r4,pc}
;;;708    
                          ENDP

00004e  0000              DCW      0x0000
                  |L27.80|
                          DCD      BitFlag
                  |L27.84|
                          DCD      0x40004840

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;834    
;;;835    int main()
000000  f7fffffe          BL       SYS_Init
;;;836    {
;;;837        SYS_Init();
;;;838    
;;;839    	GPIO_Init();
000004  f7fffffe          BL       GPIO_Init
;;;840    	UART0_Init();
000008  f7fffffe          BL       UART0_Init
;;;841     	TIMER0_Init();   
00000c  f7fffffe          BL       TIMER0_Init
;;;842    	TIMER1_Init();
000010  f7fffffe          BL       TIMER1_Init
;;;843    
;;;844        SysTick_enable(1000);
000014  207d              MOVS     r0,#0x7d
000016  00c0              LSLS     r0,r0,#3
000018  f7fffffe          BL       SysTick_enable
;;;845        #if defined (ENABLE_TICK_EVENT)
;;;846        TickSetTickEvent(1000, TickCallback_processA);  // 1000 ms
;;;847        TickSetTickEvent(5000, TickCallback_processB);  // 5000 ms
;;;848        #endif
;;;849    
;;;850        // CRC_CAL_SAMPLE();
;;;851    
;;;852        /* Got no where to go, just loop forever */
;;;853        while(1)
00001c  e001              B        |L28.34|
                  |L28.30|
;;;854        {
;;;855            loop();
00001e  f7fffffe          BL       loop
                  |L28.34|
000022  e7fc              B        |L28.30|
;;;856    
;;;857        }
;;;858    }
;;;859    
                          ENDP


                          AREA ||i.put_rc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  put_rc PROC
;;;441    
;;;442    void put_rc(uint8_t rc)
000000  b570              PUSH     {r4-r6,lr}
;;;443    {
000002  4605              MOV      r5,r0
;;;444        
;;;445        const char *p =
000004  4c09              LDR      r4,|L29.44|
;;;446            _T("error_head\0error_wrong_code\0error_wrong_data0\0error_wrong_data1\0error_wrong_data2\0error_wrong_data3\0")
;;;447            _T("error_cs\0error_tail\0error_timeout\0");
;;;448    
;;;449        uint32_t i;
;;;450        for (i = 0; (i != (unsigned int)rc) && *p; i++)
000006  2600              MOVS     r6,#0
000008  e005              B        |L29.22|
                  |L29.10|
;;;451        {
;;;452            while(*p++) ;
00000a  bf00              NOP      
                  |L29.12|
00000c  7821              LDRB     r1,[r4,#0]
00000e  1c64              ADDS     r4,r4,#1
000010  2900              CMP      r1,#0
000012  d1fb              BNE      |L29.12|
000014  1c76              ADDS     r6,r6,#1              ;450
                  |L29.22|
000016  42ae              CMP      r6,r5                 ;450
000018  d002              BEQ      |L29.32|
00001a  7820              LDRB     r0,[r4,#0]            ;450
00001c  2800              CMP      r0,#0                 ;450
00001e  d1f4              BNE      |L29.10|
                  |L29.32|
;;;453        }
;;;454        printf(_T("rc=%u result:%s\r\n"), (unsigned int)rc, p);
000020  4622              MOV      r2,r4
000022  4629              MOV      r1,r5
000024  a002              ADR      r0,|L29.48|
000026  f7fffffe          BL       __2printf
;;;455    }
00002a  bd70              POP      {r4-r6,pc}
;;;456    
                          ENDP

                  |L29.44|
                          DCD      ||.constdata||+0x110
                  |L29.48|
000030  72633d25          DCB      "rc=%u result:%s\r\n",0
000034  75207265
000038  73756c74
00003c  3a25730d
000040  0a00    
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.reset_buffer||, CODE, READONLY, ALIGN=1

                  reset_buffer PROC
;;;197    
;;;198    void reset_buffer(void *dest, unsigned int val, unsigned int size)
000000  b530              PUSH     {r4,r5,lr}
;;;199    {
;;;200        uint8_t *pu8Dest;
;;;201    //    unsigned int i;
;;;202        
;;;203        pu8Dest = (uint8_t *)dest;
000002  4603              MOV      r3,r0
;;;204    
;;;205    	#if 1
;;;206    	while (size-- > 0)
000004  e001              B        |L30.10|
                  |L30.6|
;;;207    		*pu8Dest++ = val;
000006  7019              STRB     r1,[r3,#0]
000008  1c5b              ADDS     r3,r3,#1
                  |L30.10|
00000a  4614              MOV      r4,r2                 ;206
00000c  1e52              SUBS     r2,r2,#1              ;206
00000e  2c00              CMP      r4,#0                 ;206
000010  d1f9              BNE      |L30.6|
;;;208    	#else
;;;209    	memset(pu8Dest, val, size * (sizeof(pu8Dest[0]) ));
;;;210    	#endif
;;;211    	
;;;212    }
000012  bd30              POP      {r4,r5,pc}
;;;213    
                          ENDP


                          AREA ||i.rx_rcv_irq||, CODE, READONLY, ALIGN=2

                  rx_rcv_irq PROC
;;;535    
;;;536    void rx_rcv_irq(uint8_t c)
000000  b510              PUSH     {r4,lr}
;;;537    {    
000002  4604              MOV      r4,r0
;;;538        if (c == 0x0D /*|| c == UART_CMD_FMT_TAIL*/)                        //hit enter or tail judged that the input is completed
000004  2c0d              CMP      r4,#0xd
000006  d10a              BNE      |L31.30|
;;;539        {
;;;540            u32rcvtick = 0;
000008  2000              MOVS     r0,#0
00000a  4923              LDR      r1,|L31.152|
00000c  6008              STR      r0,[r1,#0]  ; u32rcvtick
;;;541            set_flag(flag_uart_rx_rcv_timeout_10000ms ,ENABLE);
00000e  4823              LDR      r0,|L31.156|
000010  6800              LDR      r0,[r0,#0]  ; BitFlag
000012  2104              MOVS     r1,#4
000014  4308              ORRS     r0,r0,r1
000016  4921              LDR      r1,|L31.156|
000018  6008              STR      r0,[r1,#0]  ; BitFlag
;;;542            stop_timer0();
00001a  f7fffffe          BL       stop_timer0
                  |L31.30|
;;;543        }
;;;544    
;;;545        if (uart_rcv_cnt < (UART_RX_RCV_LEN-1))
00001e  4820              LDR      r0,|L31.160|
000020  7800              LDRB     r0,[r0,#0]  ; uart_rcv_cnt
000022  2807              CMP      r0,#7
000024  da19              BGE      |L31.90|
;;;546        {
;;;547            if (c == 0x7F || c == 0x08)                                 //Delete or Backspace
000026  2c7f              CMP      r4,#0x7f
000028  d001              BEQ      |L31.46|
00002a  2c08              CMP      r4,#8
00002c  d105              BNE      |L31.58|
                  |L31.46|
;;;548            {
;;;549                uart_rcv_cnt--;
00002e  481c              LDR      r0,|L31.160|
000030  7800              LDRB     r0,[r0,#0]  ; uart_rcv_cnt
000032  1e40              SUBS     r0,r0,#1
000034  491a              LDR      r1,|L31.160|
000036  7008              STRB     r0,[r1,#0]
000038  e008              B        |L31.76|
                  |L31.58|
;;;550            }
;;;551            else
;;;552            {
;;;553                RXBUFFER[uart_rcv_cnt] = c;
00003a  481a              LDR      r0,|L31.164|
00003c  4918              LDR      r1,|L31.160|
00003e  7809              LDRB     r1,[r1,#0]  ; uart_rcv_cnt
000040  5444              STRB     r4,[r0,r1]
;;;554                uart_rcv_cnt++;
000042  4817              LDR      r0,|L31.160|
000044  7800              LDRB     r0,[r0,#0]  ; uart_rcv_cnt
000046  1c40              ADDS     r0,r0,#1
000048  4915              LDR      r1,|L31.160|
00004a  7008              STRB     r0,[r1,#0]
                  |L31.76|
;;;555            }
;;;556    
;;;557            if (uart_rcv_cnt == 1)
00004c  4814              LDR      r0,|L31.160|
00004e  7800              LDRB     r0,[r0,#0]  ; uart_rcv_cnt
000050  2801              CMP      r0,#1
000052  d11f              BNE      |L31.148|
;;;558            {
;;;559                start_timer0();
000054  f7fffffe          BL       start_timer0
000058  e01c              B        |L31.148|
                  |L31.90|
;;;560            }
;;;561    
;;;562        }
;;;563        else if (uart_rcv_cnt ==  (UART_RX_RCV_LEN-1))
00005a  4811              LDR      r0,|L31.160|
00005c  7800              LDRB     r0,[r0,#0]  ; uart_rcv_cnt
00005e  2807              CMP      r0,#7
000060  d118              BNE      |L31.148|
;;;564        {
;;;565            if (c == 0x7F || c == 0x08)                                 //Delete or Backspace
000062  2c7f              CMP      r4,#0x7f
000064  d001              BEQ      |L31.106|
000066  2c08              CMP      r4,#8
000068  d105              BNE      |L31.118|
                  |L31.106|
;;;566            {
;;;567                uart_rcv_cnt--;
00006a  480d              LDR      r0,|L31.160|
00006c  7800              LDRB     r0,[r0,#0]  ; uart_rcv_cnt
00006e  1e40              SUBS     r0,r0,#1
000070  490b              LDR      r1,|L31.160|
000072  7008              STRB     r0,[r1,#0]
000074  e00e              B        |L31.148|
                  |L31.118|
;;;568            }
;;;569            else
;;;570            {
;;;571                RXBUFFER[uart_rcv_cnt] = c;
000076  480b              LDR      r0,|L31.164|
000078  4909              LDR      r1,|L31.160|
00007a  7809              LDRB     r1,[r1,#0]  ; uart_rcv_cnt
00007c  5444              STRB     r4,[r0,r1]
;;;572                set_flag(flag_uart_rx_rcv_ready ,ENABLE); 
00007e  4807              LDR      r0,|L31.156|
000080  6800              LDR      r0,[r0,#0]  ; BitFlag
000082  2108              MOVS     r1,#8
000084  4308              ORRS     r0,r0,r1
000086  4905              LDR      r1,|L31.156|
000088  6008              STR      r0,[r1,#0]  ; BitFlag
;;;573                uart_rcv_cnt = 0;
00008a  2000              MOVS     r0,#0
00008c  4904              LDR      r1,|L31.160|
00008e  7008              STRB     r0,[r1,#0]
;;;574                stop_timer0();
000090  f7fffffe          BL       stop_timer0
                  |L31.148|
;;;575            }
;;;576        }    
;;;577    }
000094  bd10              POP      {r4,pc}
;;;578    
                          ENDP

000096  0000              DCW      0x0000
                  |L31.152|
                          DCD      u32rcvtick
                  |L31.156|
                          DCD      BitFlag
                  |L31.160|
                          DCD      uart_rcv_cnt
                  |L31.164|
                          DCD      RXBUFFER

                          AREA ||i.set_systick||, CODE, READONLY, ALIGN=2

                  set_systick PROC
;;;137    
;;;138    void set_systick(uint32_t t)
000000  4901              LDR      r1,|L32.8|
;;;139    {
;;;140    	counter_systick = t;
000002  6008              STR      r0,[r1,#0]  ; counter_systick
;;;141    }
000004  4770              BX       lr
;;;142    
                          ENDP

000006  0000              DCW      0x0000
                  |L32.8|
                          DCD      counter_systick

                          AREA ||i.set_tick||, CODE, READONLY, ALIGN=2

                  set_tick PROC
;;;152    
;;;153    void set_tick(uint32_t t)
000000  4901              LDR      r1,|L33.8|
;;;154    {
;;;155    	counter_tick = t;
000002  6008              STR      r0,[r1,#0]  ; counter_tick
;;;156    }
000004  4770              BX       lr
;;;157    
                          ENDP

000006  0000              DCW      0x0000
                  |L33.8|
                          DCD      counter_tick

                          AREA ||i.start_timer0||, CODE, READONLY, ALIGN=2

                  start_timer0 PROC
;;;434    
;;;435    void start_timer0(void)
000000  b510              PUSH     {r4,lr}
;;;436    {
;;;437        TIMER_EnableInt(TIMER0);
000002  4803              LDR      r0,|L34.16|
000004  f7fffffe          BL       TIMER_EnableInt
;;;438        TIMER_Start(TIMER0);
000008  4801              LDR      r0,|L34.16|
00000a  f7fffffe          BL       TIMER_Start
;;;439    }
00000e  bd10              POP      {r4,pc}
;;;440    
                          ENDP

                  |L34.16|
                          DCD      0x40050000

                          AREA ||i.stop_timer0||, CODE, READONLY, ALIGN=2

                  stop_timer0 PROC
;;;427    
;;;428    void stop_timer0(void)
000000  bf00              NOP      
000002  2001              MOVS     r0,#1
000004  490a              LDR      r1,|L35.48|
000006  6088              STR      r0,[r1,#8]
000008  bf00              NOP      
;;;429    {
;;;430        TIMER_ClearIntFlag(TIMER0);    
;;;431        TIMER_DisableInt(TIMER0); 
00000a  bf00              NOP      
00000c  4608              MOV      r0,r1
00000e  6800              LDR      r0,[r0,#0]
000010  2101              MOVS     r1,#1
000012  0749              LSLS     r1,r1,#29
000014  4388              BICS     r0,r0,r1
000016  4906              LDR      r1,|L35.48|
000018  6008              STR      r0,[r1,#0]
00001a  bf00              NOP      
;;;432        TIMER_Stop(TIMER0);        
00001c  bf00              NOP      
00001e  4608              MOV      r0,r1
000020  6800              LDR      r0,[r0,#0]
000022  0389              LSLS     r1,r1,#14
000024  4388              BICS     r0,r0,r1
000026  4902              LDR      r1,|L35.48|
000028  6008              STR      r0,[r1,#0]
00002a  bf00              NOP      
;;;433    }
00002c  4770              BX       lr
;;;434    
                          ENDP

00002e  0000              DCW      0x0000
                  |L35.48|
                          DCD      0x40050000

                          AREA ||i.systick_counter||, CODE, READONLY, ALIGN=2

                  systick_counter PROC
;;;142    
;;;143    void systick_counter(void)
000000  4802              LDR      r0,|L36.12|
;;;144    {
;;;145    	counter_systick++;
000002  6800              LDR      r0,[r0,#0]  ; counter_systick
000004  1c40              ADDS     r0,r0,#1
000006  4901              LDR      r1,|L36.12|
000008  6008              STR      r0,[r1,#0]  ; counter_systick
;;;146    }
00000a  4770              BX       lr
;;;147    
                          ENDP

                  |L36.12|
                          DCD      counter_systick

                          AREA ||i.tick_counter||, CODE, READONLY, ALIGN=2

                  tick_counter PROC
;;;157    
;;;158    void tick_counter(void)
000000  b500              PUSH     {lr}
;;;159    {
;;;160    	counter_tick++;
000002  4807              LDR      r0,|L37.32|
000004  6800              LDR      r0,[r0,#0]  ; counter_tick
000006  1c40              ADDS     r0,r0,#1
000008  4905              LDR      r1,|L37.32|
00000a  6008              STR      r0,[r1,#0]  ; counter_tick
;;;161        if (get_tick() >= 60000)
00000c  f7fffffe          BL       get_tick
000010  4904              LDR      r1,|L37.36|
000012  4288              CMP      r0,r1
000014  d302              BCC      |L37.28|
;;;162        {
;;;163            set_tick(0);
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       set_tick
                  |L37.28|
;;;164        }
;;;165    }
00001c  bd00              POP      {pc}
;;;166    
                          ENDP

00001e  0000              DCW      0x0000
                  |L37.32|
                          DCD      counter_tick
                  |L37.36|
                          DCD      0x0000ea60

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  CRC8TAB
000000  00316253          DCB      0x00,0x31,0x62,0x53
000004  c4f5a697          DCB      0xc4,0xf5,0xa6,0x97
000008  b988dbea          DCB      0xb9,0x88,0xdb,0xea
00000c  7d4c1f2e          DCB      0x7d,0x4c,0x1f,0x2e
000010  43722110          DCB      0x43,0x72,0x21,0x10
000014  87b6e5d4          DCB      0x87,0xb6,0xe5,0xd4
000018  facb98a9          DCB      0xfa,0xcb,0x98,0xa9
00001c  3e0f5c6d          DCB      0x3e,0x0f,0x5c,0x6d
000020  86b7e4d5          DCB      0x86,0xb7,0xe4,0xd5
000024  42732011          DCB      0x42,0x73,0x20,0x11
000028  3f0e5d6c          DCB      0x3f,0x0e,0x5d,0x6c
00002c  fbca99a8          DCB      0xfb,0xca,0x99,0xa8
000030  c5f4a796          DCB      0xc5,0xf4,0xa7,0x96
000034  01306352          DCB      0x01,0x30,0x63,0x52
000038  7c4d1e2f          DCB      0x7c,0x4d,0x1e,0x2f
00003c  b889daeb          DCB      0xb8,0x89,0xda,0xeb
000040  3d0c5f6e          DCB      0x3d,0x0c,0x5f,0x6e
000044  f9c89baa          DCB      0xf9,0xc8,0x9b,0xaa
000048  84b5e6d7          DCB      0x84,0xb5,0xe6,0xd7
00004c  40712213          DCB      0x40,0x71,0x22,0x13
000050  7e4f1c2d          DCB      0x7e,0x4f,0x1c,0x2d
000054  ba8bd8e9          DCB      0xba,0x8b,0xd8,0xe9
000058  c7f6a594          DCB      0xc7,0xf6,0xa5,0x94
00005c  03326150          DCB      0x03,0x32,0x61,0x50
000060  bb8ad9e8          DCB      0xbb,0x8a,0xd9,0xe8
000064  7f4e1d2c          DCB      0x7f,0x4e,0x1d,0x2c
000068  02336051          DCB      0x02,0x33,0x60,0x51
00006c  c6f7a495          DCB      0xc6,0xf7,0xa4,0x95
000070  f8c99aab          DCB      0xf8,0xc9,0x9a,0xab
000074  3c0d5e6f          DCB      0x3c,0x0d,0x5e,0x6f
000078  41702312          DCB      0x41,0x70,0x23,0x12
00007c  85b4e7d6          DCB      0x85,0xb4,0xe7,0xd6
000080  7a4b1829          DCB      0x7a,0x4b,0x18,0x29
000084  be8fdced          DCB      0xbe,0x8f,0xdc,0xed
000088  c3f2a190          DCB      0xc3,0xf2,0xa1,0x90
00008c  07366554          DCB      0x07,0x36,0x65,0x54
000090  39085b6a          DCB      0x39,0x08,0x5b,0x6a
000094  fdcc9fae          DCB      0xfd,0xcc,0x9f,0xae
000098  80b1e2d3          DCB      0x80,0xb1,0xe2,0xd3
00009c  44752617          DCB      0x44,0x75,0x26,0x17
0000a0  fccd9eaf          DCB      0xfc,0xcd,0x9e,0xaf
0000a4  38095a6b          DCB      0x38,0x09,0x5a,0x6b
0000a8  45742716          DCB      0x45,0x74,0x27,0x16
0000ac  81b0e3d2          DCB      0x81,0xb0,0xe3,0xd2
0000b0  bf8eddec          DCB      0xbf,0x8e,0xdd,0xec
0000b4  7b4a1928          DCB      0x7b,0x4a,0x19,0x28
0000b8  06376455          DCB      0x06,0x37,0x64,0x55
0000bc  c2f3a091          DCB      0xc2,0xf3,0xa0,0x91
0000c0  47762514          DCB      0x47,0x76,0x25,0x14
0000c4  83b2e1d0          DCB      0x83,0xb2,0xe1,0xd0
0000c8  fecf9cad          DCB      0xfe,0xcf,0x9c,0xad
0000cc  3a0b5869          DCB      0x3a,0x0b,0x58,0x69
0000d0  04356657          DCB      0x04,0x35,0x66,0x57
0000d4  c0f1a293          DCB      0xc0,0xf1,0xa2,0x93
0000d8  bd8cdffe          DCB      0xbd,0x8c,0xdf,0xfe
0000dc  79481b2a          DCB      0x79,0x48,0x1b,0x2a
0000e0  c1f0a392          DCB      0xc1,0xf0,0xa3,0x92
0000e4  05346756          DCB      0x05,0x34,0x67,0x56
0000e8  78491a2b          DCB      0x78,0x49,0x1a,0x2b
0000ec  bc8ddeef          DCB      0xbc,0x8d,0xde,0xef
0000f0  82b3e0d1          DCB      0x82,0xb3,0xe0,0xd1
0000f4  46772415          DCB      0x46,0x77,0x24,0x15
0000f8  3b0a5968          DCB      0x3b,0x0a,0x59,0x68
0000fc  ffce9dac          DCB      0xff,0xce,0x9d,0xac
                  __FUNCTION__
000100  636f6d70          DCB      0x63,0x6f,0x6d,0x70
000104  6172655f          DCB      0x61,0x72,0x65,0x5f
000108  62756666          DCB      0x62,0x75,0x66,0x66
00010c  65720000          DCB      0x65,0x72,0x00,0x00
000110  6572726f          DCB      0x65,0x72,0x72,0x6f
000114  725f6865          DCB      0x72,0x5f,0x68,0x65
000118  61640065          DCB      0x61,0x64,0x00,0x65
00011c  72726f72          DCB      0x72,0x72,0x6f,0x72
000120  5f77726f          DCB      0x5f,0x77,0x72,0x6f
000124  6e675f63          DCB      0x6e,0x67,0x5f,0x63
000128  6f646500          DCB      0x6f,0x64,0x65,0x00
00012c  6572726f          DCB      0x65,0x72,0x72,0x6f
000130  725f7772          DCB      0x72,0x5f,0x77,0x72
000134  6f6e675f          DCB      0x6f,0x6e,0x67,0x5f
000138  64617461          DCB      0x64,0x61,0x74,0x61
00013c  30006572          DCB      0x30,0x00,0x65,0x72
000140  726f725f          DCB      0x72,0x6f,0x72,0x5f
000144  77726f6e          DCB      0x77,0x72,0x6f,0x6e
000148  675f6461          DCB      0x67,0x5f,0x64,0x61
00014c  74613100          DCB      0x74,0x61,0x31,0x00
000150  6572726f          DCB      0x65,0x72,0x72,0x6f
000154  725f7772          DCB      0x72,0x5f,0x77,0x72
000158  6f6e675f          DCB      0x6f,0x6e,0x67,0x5f
00015c  64617461          DCB      0x64,0x61,0x74,0x61
000160  32006572          DCB      0x32,0x00,0x65,0x72
000164  726f725f          DCB      0x72,0x6f,0x72,0x5f
000168  77726f6e          DCB      0x77,0x72,0x6f,0x6e
00016c  675f6461          DCB      0x67,0x5f,0x64,0x61
000170  74613300          DCB      0x74,0x61,0x33,0x00
000174  6572726f          DCB      0x65,0x72,0x72,0x6f
000178  725f6373          DCB      0x72,0x5f,0x63,0x73
00017c  00657272          DCB      0x00,0x65,0x72,0x72
000180  6f725f74          DCB      0x6f,0x72,0x5f,0x74
000184  61696c00          DCB      0x61,0x69,0x6c,0x00
000188  6572726f          DCB      0x65,0x72,0x72,0x6f
00018c  725f7469          DCB      0x72,0x5f,0x74,0x69
000190  6d656f75          DCB      0x6d,0x65,0x6f,0x75
000194  740000            DCB      0x74,0x00,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  BitFlag
                          DCD      0x00000000
                  counter_tick
                          DCD      0x00000000
                  counter_systick
                          DCD      0x00000000
                  cmd_fmt_index
00000c  00                DCB      0x00
                  err_fmt_index
00000d  00                DCB      0x00
                  RXBUFFER
00000e  0000              DCB      0x00,0x00
                          DCD      0x00000000
000014  0000              DCB      0x00,0x00
                  uart_rcv_cnt
000016  0000              DCB      0x00,0x00
                  u32rcvtick
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
