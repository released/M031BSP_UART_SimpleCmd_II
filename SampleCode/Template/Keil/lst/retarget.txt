; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\retarget.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\retarget.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\retarget.crf ..\..\..\Library\StdDriver\src\retarget.c]
                          THUMB

                          AREA ||i.GetChar||, CODE, READONLY, ALIGN=2

                  GetChar PROC
;;;563     */
;;;564    static char GetChar(void)
000000  e00a              B        |L1.24|
                  |L1.2|
;;;565    {
;;;566    #ifdef DEBUG_ENABLE_SEMIHOST
;;;567    # if defined (__CC_ARM)
;;;568        int nRet;
;;;569        while(SH_DoCommand(0x101, 0, &nRet) != 0)
;;;570        {
;;;571            if(nRet != 0)
;;;572            {
;;;573                SH_DoCommand(0x07, 0, &nRet);
;;;574                return (char)nRet;
;;;575            }
;;;576        }
;;;577    # else
;;;578        int nRet;
;;;579        while(SH_DoCommand(0x7, 0, &nRet) != 0)
;;;580        {
;;;581            if(nRet != 0)
;;;582                return (char)nRet;
;;;583        }
;;;584    # endif
;;;585        return (0);
;;;586    #else
;;;587    #ifndef DISABLE_UART
;;;588        while(1)
;;;589        {
;;;590            if((DEBUG_PORT->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk) == 0)
000002  4806              LDR      r0,|L1.28|
000004  6980              LDR      r0,[r0,#0x18]
000006  2101              MOVS     r1,#1
000008  0389              LSLS     r1,r1,#14
00000a  4008              ANDS     r0,r0,r1
00000c  2800              CMP      r0,#0
00000e  d103              BNE      |L1.24|
;;;591            {
;;;592                return (DEBUG_PORT->DAT);
000010  4802              LDR      r0,|L1.28|
000012  6800              LDR      r0,[r0,#0]
000014  b2c0              UXTB     r0,r0
;;;593            }
;;;594        }
;;;595    #else
;;;596        return 0;
;;;597    #endif
;;;598    #endif
;;;599    }
000016  4770              BX       lr
                  |L1.24|
000018  e7f3              B        |L1.2|
;;;600    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x40070000

                          AREA ||i.Hard_Fault_Handler||, CODE, READONLY, ALIGN=2

                  Hard_Fault_Handler PROC
                  ||__tagsym$$used||
;;;76      */
;;;77     void Hard_Fault_Handler(uint32_t stack[])
000000  4604              MOV      r4,r0
;;;78     {
;;;79         printf("In Hard Fault Handler\n");
000002  a004              ADR      r0,|L2.20|
000004  f7fffffe          BL       __2printf
;;;80     
;;;81         stackDump(stack);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       stackDump
;;;82         /* Replace while(1) with chip reset if WDT is not enabled for end product */
;;;83         while(1);
00000e  bf00              NOP      
                  |L2.16|
000010  e7fe              B        |L2.16|
;;;84         /* SYS->IPRST0 = SYS_IPRST0_CHIPRST_Msk; */
;;;85     }
;;;86     
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
000014  496e2048          DCB      "In Hard Fault Handler\n",0
000018  61726420
00001c  4661756c
000020  74204861
000024  6e646c65
000028  720a00  
00002b  00                DCB      0

                          AREA ||i.IsDebugFifoEmpty||, CODE, READONLY, ALIGN=2

                  IsDebugFifoEmpty PROC
;;;630    
;;;631    int IsDebugFifoEmpty(void)
000000  4803              LDR      r0,|L3.16|
;;;632    {
;;;633    #ifndef DISABLE_UART
;;;634        return ((DEBUG_PORT->FIFOSTS & UART_FIFOSTS_TXEMPTYF_Msk) != 0);
000002  6980              LDR      r0,[r0,#0x18]
000004  2101              MOVS     r1,#1
000006  0709              LSLS     r1,r1,#28
000008  4008              ANDS     r0,r0,r1
00000a  0f00              LSRS     r0,r0,#28
;;;635    #else
;;;636        return 1;
;;;637    #endif
;;;638    }
00000c  4770              BX       lr
;;;639    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0x40070000

                          AREA ||i.SendChar||, CODE, READONLY, ALIGN=1

                  SendChar PROC
;;;520     */
;;;521    static void SendChar(int ch)
000000  b510              PUSH     {r4,lr}
;;;522    {
000002  4604              MOV      r4,r0
;;;523    #if defined(DEBUG_ENABLE_SEMIHOST)
;;;524        g_buf[g_buf_len++] = ch;
;;;525        g_buf[g_buf_len] = '\0';
;;;526        if(g_buf_len + 1 >= sizeof(g_buf) || ch == '\n' || ch == '\0')
;;;527        {
;;;528            /* Send the char */
;;;529            if(SH_DoCommand(0x04, (int)g_buf, NULL) != 0)
;;;530            {
;;;531                /* Enable SEMIHOST and it is valid (run ICE debug mode) */
;;;532                g_buf_len = 0;
;;;533                return;
;;;534            }
;;;535            else
;;;536            {
;;;537                /* Enable SEMIHOST but it is invalid (NOT run ICE debug mode) */
;;;538      #ifndef DISABLE_UART
;;;539                /* printf to UART if semihost is invalid */
;;;540                int i;
;;;541    
;;;542                for(i = 0; i < g_buf_len; i++)
;;;543                    SendChar_ToUART(g_buf[i]);
;;;544      #endif
;;;545                g_buf_len = 0;
;;;546            }
;;;547        }
;;;548    #else
;;;549      #ifndef DISABLE_UART
;;;550        SendChar_ToUART(ch);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SendChar_ToUART
;;;551      #endif
;;;552    #endif
;;;553    }
00000a  bd10              POP      {r4,pc}
;;;554    
                          ENDP


                          AREA ||i.SendChar_ToUART||, CODE, READONLY, ALIGN=2

                  SendChar_ToUART PROC
;;;441    #ifndef NONBLOCK_PRINTF
;;;442    static void SendChar_ToUART(int ch)
000000  bf00              NOP      
                  |L5.2|
;;;443    {
;;;444        while(DEBUG_PORT->FIFOSTS & UART_FIFOSTS_TXFULL_Msk);
000002  490b              LDR      r1,|L5.48|
000004  6989              LDR      r1,[r1,#0x18]
000006  2201              MOVS     r2,#1
000008  05d2              LSLS     r2,r2,#23
00000a  4011              ANDS     r1,r1,r2
00000c  2900              CMP      r1,#0
00000e  d1f8              BNE      |L5.2|
;;;445    
;;;446        if(ch == '\n')
000010  280a              CMP      r0,#0xa
000012  d10a              BNE      |L5.42|
;;;447        {
;;;448            DEBUG_PORT->DAT = '\r';
000014  210d              MOVS     r1,#0xd
000016  4a06              LDR      r2,|L5.48|
000018  6011              STR      r1,[r2,#0]
;;;449            while(DEBUG_PORT->FIFOSTS & UART_FIFOSTS_TXFULL_Msk);
00001a  bf00              NOP      
                  |L5.28|
00001c  4904              LDR      r1,|L5.48|
00001e  6989              LDR      r1,[r1,#0x18]
000020  2201              MOVS     r2,#1
000022  05d2              LSLS     r2,r2,#23
000024  4011              ANDS     r1,r1,r2
000026  2900              CMP      r1,#0
000028  d1f8              BNE      |L5.28|
                  |L5.42|
;;;450        }
;;;451        DEBUG_PORT->DAT = ch;
00002a  4901              LDR      r1,|L5.48|
00002c  6008              STR      r0,[r1,#0]
;;;452    }
00002e  4770              BX       lr
;;;453    
                          ENDP

                  |L5.48|
                          DCD      0x40070000

                          AREA ||i._ttywrch||, CODE, READONLY, ALIGN=1

                  _ttywrch PROC
;;;649    
;;;650    void _ttywrch(int ch)
000000  b510              PUSH     {r4,lr}
;;;651    {
000002  4604              MOV      r4,r0
;;;652        SendChar(ch);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SendChar
;;;653        return;
;;;654    }
00000a  bd10              POP      {r4,pc}
;;;655    
                          ENDP


                          AREA ||i.ferror||, CODE, READONLY, ALIGN=1

                  ferror PROC
;;;744    
;;;745    int ferror(FILE *stream)
000000  4601              MOV      r1,r0
;;;746    {
;;;747        return EOF;
000002  2000              MOVS     r0,#0
000004  43c0              MVNS     r0,r0
;;;748    }
000006  4770              BX       lr
;;;749    #endif
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;724    
;;;725    int fgetc(FILE *stream)
000000  b510              PUSH     {r4,lr}
;;;726    {
000002  4604              MOV      r4,r0
;;;727        return (GetChar());
000004  f7fffffe          BL       GetChar
;;;728    }
000008  bd10              POP      {r4,pc}
;;;729    
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;674    
;;;675    int fputc(int ch, FILE *stream)
000000  b570              PUSH     {r4-r6,lr}
;;;676    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;677        SendChar(ch);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       SendChar
;;;678        return ch;
00000c  4620              MOV      r0,r4
;;;679    }
00000e  bd70              POP      {r4-r6,pc}
;;;680    
                          ENDP


                          AREA ||i.kbhit||, CODE, READONLY, ALIGN=2

                  kbhit PROC
;;;611    
;;;612    int kbhit(void)
000000  4803              LDR      r0,|L10.16|
;;;613    {
;;;614    #ifndef DISABLE_UART
;;;615        return !((DEBUG_PORT->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk) == 0);
000002  6980              LDR      r0,[r0,#0x18]
000004  2101              MOVS     r1,#1
000006  0389              LSLS     r1,r1,#14
000008  4008              ANDS     r0,r0,r1
00000a  0b80              LSRS     r0,r0,#14
;;;616    #else
;;;617        return 0;
;;;618    #endif
;;;619    }
00000c  4770              BX       lr
;;;620    /**
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      0x40070000

                          AREA ||i.stackDump||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  stackDump PROC
;;;58      */
;;;59     static void stackDump(uint32_t stack[])
000000  b510              PUSH     {r4,lr}
;;;60     {
000002  4604              MOV      r4,r0
;;;61         printf("r0  = 0x%x\n", stack[r0]);
000004  a010              ADR      r0,|L11.72|
000006  6821              LDR      r1,[r4,#0]
000008  f7fffffe          BL       __2printf
;;;62         printf("r1  = 0x%x\n", stack[r1]);
00000c  a011              ADR      r0,|L11.84|
00000e  6861              LDR      r1,[r4,#4]
000010  f7fffffe          BL       __2printf
;;;63         printf("r2  = 0x%x\n", stack[r2]);
000014  a012              ADR      r0,|L11.96|
000016  68a1              LDR      r1,[r4,#8]
000018  f7fffffe          BL       __2printf
;;;64         printf("r3  = 0x%x\n", stack[r3]);
00001c  a013              ADR      r0,|L11.108|
00001e  68e1              LDR      r1,[r4,#0xc]
000020  f7fffffe          BL       __2printf
;;;65         printf("r12 = 0x%x\n", stack[r12]);
000024  a014              ADR      r0,|L11.120|
000026  6921              LDR      r1,[r4,#0x10]
000028  f7fffffe          BL       __2printf
;;;66         printf("lr  = 0x%x\n", stack[lr]);
00002c  a015              ADR      r0,|L11.132|
00002e  6961              LDR      r1,[r4,#0x14]
000030  f7fffffe          BL       __2printf
;;;67         printf("pc  = 0x%x\n", stack[pc]);
000034  a016              ADR      r0,|L11.144|
000036  69a1              LDR      r1,[r4,#0x18]
000038  f7fffffe          BL       __2printf
;;;68         printf("psr = 0x%x\n", stack[psr]);
00003c  a017              ADR      r0,|L11.156|
00003e  69e1              LDR      r1,[r4,#0x1c]
000040  f7fffffe          BL       __2printf
;;;69     }
000044  bd10              POP      {r4,pc}
;;;70     
                          ENDP

000046  0000              DCW      0x0000
                  |L11.72|
000048  72302020          DCB      "r0  = 0x%x\n",0
00004c  3d203078
000050  25780a00
                  |L11.84|
000054  72312020          DCB      "r1  = 0x%x\n",0
000058  3d203078
00005c  25780a00
                  |L11.96|
000060  72322020          DCB      "r2  = 0x%x\n",0
000064  3d203078
000068  25780a00
                  |L11.108|
00006c  72332020          DCB      "r3  = 0x%x\n",0
000070  3d203078
000074  25780a00
                  |L11.120|
000078  72313220          DCB      "r12 = 0x%x\n",0
00007c  3d203078
000080  25780a00
                  |L11.132|
000084  6c722020          DCB      "lr  = 0x%x\n",0
000088  3d203078
00008c  25780a00
                  |L11.144|
000090  70632020          DCB      "pc  = 0x%x\n",0
000094  3d203078
000098  25780a00
                  |L11.156|
00009c  70737220          DCB      "psr = 0x%x\n",0
0000a0  3d203078
0000a4  25780a00

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000
                  __stdin
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\retarget.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_retarget_c_d5a1b03f____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_retarget_c_d5a1b03f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_retarget_c_d5a1b03f____REVSH|
#line 402
|__asm___10_retarget_c_d5a1b03f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |HardFault_Handler|
#line 411 "..\\..\\..\\Library\\StdDriver\\src\\retarget.c"
|HardFault_Handler| PROC
#line 412

 MOVS r0, #4
 MOV r1, LR
 TST r0, r1  
 BEQ Stack_Use_MSP  
 MRS R0, PSP  
 B Get_LR_and_Branch
Stack_Use_MSP
 MRS R0, MSP  
Get_LR_and_Branch
 MOV R1, LR  
 LDR R2,= |Hard_Fault_Handler|  
 BX R2
	ENDP

;*** End   embedded assembler ***
