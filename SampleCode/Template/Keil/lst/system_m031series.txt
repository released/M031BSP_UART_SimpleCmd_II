; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\system_m031series.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\system_m031series.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\system_m031series.crf ..\..\..\Library\Device\Nuvoton\M031\Source\system_M031Series.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;456      */
;;;457    static __INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;458    {
;;;459        uint32_t u32PllFreq;
;;;460        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;461        uint8_t au8NoTbl[4] = {1, 2, 2, 4}; /* OUTDIV :DEF: {1, 2, 2, 4} */
000002  a01b              ADR      r0,|L1.112|
000004  6800              LDR      r0,[r0,#0]
000006  9000              STR      r0,[sp,#0]
;;;462        uint32_t u32Reg;
;;;463    
;;;464        u32PllFreq = 0;
000008  2000              MOVS     r0,#0
00000a  9002              STR      r0,[sp,#8]
;;;465        u32Reg = CLK->PLLCTL;
00000c  4819              LDR      r0,|L1.116|
00000e  6804              LDR      r4,[r0,#0]
;;;466    
;;;467        if ((u32Reg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk)) == 0)
000010  2005              MOVS     r0,#5
000012  0400              LSLS     r0,r0,#16
000014  4020              ANDS     r0,r0,r4
000016  2800              CMP      r0,#0
000018  d127              BNE      |L1.106|
;;;468        {
;;;469            /* PLL is enabled and output enabled */
;;;470            if (u32Reg & CLK_PLLCTL_PLLSRC_Msk)
00001a  2001              MOVS     r0,#1
00001c  04c0              LSLS     r0,r0,#19
00001e  4020              ANDS     r0,r0,r4
000020  2800              CMP      r0,#0
000022  d001              BEQ      |L1.40|
;;;471            {
;;;472                u32FIN = (__HIRC >> 2);
000024  4d14              LDR      r5,|L1.120|
000026  e000              B        |L1.42|
                  |L1.40|
;;;473            } else
;;;474                u32FIN = __HXT;
000028  4d14              LDR      r5,|L1.124|
                  |L1.42|
;;;475    
;;;476            if (u32Reg & CLK_PLLCTL_BP_Msk)
00002a  2001              MOVS     r0,#1
00002c  0440              LSLS     r0,r0,#17
00002e  4020              ANDS     r0,r0,r4
000030  2800              CMP      r0,#0
000032  d001              BEQ      |L1.56|
;;;477            {
;;;478                /* PLL is in bypass mode */
;;;479                u32PllFreq = u32FIN;
000034  9502              STR      r5,[sp,#8]
000036  e018              B        |L1.106|
                  |L1.56|
;;;480            }
;;;481            else
;;;482            {
;;;483                /* PLL is in normal work mode */
;;;484                u32NO = au8NoTbl[((u32Reg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
000038  2003              MOVS     r0,#3
00003a  0380              LSLS     r0,r0,#14
00003c  4020              ANDS     r0,r0,r4
00003e  0b80              LSRS     r0,r0,#14
000040  4669              MOV      r1,sp
000042  5c0a              LDRB     r2,[r1,r0]
000044  9201              STR      r2,[sp,#4]
;;;485                u32NF  = ((u32Reg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
000046  05e0              LSLS     r0,r4,#23
000048  0dc0              LSRS     r0,r0,#23
00004a  1c86              ADDS     r6,r0,#2
;;;486                u32NR  = ((u32Reg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
00004c  201f              MOVS     r0,#0x1f
00004e  0240              LSLS     r0,r0,#9
000050  4020              ANDS     r0,r0,r4
000052  0a40              LSRS     r0,r0,#9
000054  1c87              ADDS     r7,r0,#2
;;;487                /* u32FIN is shifted 2 bits to avoid overflow */
;;;488                u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
000056  9a01              LDR      r2,[sp,#4]
000058  437a              MULS     r2,r7,r2
00005a  4611              MOV      r1,r2
00005c  08aa              LSRS     r2,r5,#2
00005e  4372              MULS     r2,r6,r2
000060  4610              MOV      r0,r2
000062  f7fffffe          BL       __aeabi_uidivmod
000066  0080              LSLS     r0,r0,#2
000068  9002              STR      r0,[sp,#8]
                  |L1.106|
;;;489            }
;;;490        }
;;;491    
;;;492        return u32PllFreq;
00006a  9802              LDR      r0,[sp,#8]
;;;493    }
00006c  bdfe              POP      {r1-r7,pc}
;;;494    
                          ENDP

00006e  0000              DCW      0x0000
                  |L1.112|
000070  01020204          DCB      1,2,2,4
                  |L1.116|
                          DCD      0x40000240
                  |L1.120|
                          DCD      0x00b71b00
                  |L1.124|
                          DCD      0x01e84800

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;37      */
;;;38     void SystemCoreClockUpdate(void)
000000  b570              PUSH     {r4-r6,lr}
;;;39     {
;;;40         uint32_t u32Freq, u32ClkSrc;
;;;41         uint32_t u32HclkDiv;
;;;42     
;;;43         u32ClkSrc = CLK->CLKSEL0 & CLK_CLKSEL0_HCLKSEL_Msk;
000002  4812              LDR      r0,|L2.76|
000004  6900              LDR      r0,[r0,#0x10]
000006  0745              LSLS     r5,r0,#29
000008  0f6d              LSRS     r5,r5,#29
;;;44     
;;;45         /* Update PLL Clock */
;;;46         PllClock = CLK_GetPLLClockFreq();
00000a  f7fffffe          BL       CLK_GetPLLClockFreq
00000e  4910              LDR      r1,|L2.80|
000010  6008              STR      r0,[r1,#0]  ; PllClock
;;;47     
;;;48         if(u32ClkSrc != CLK_CLKSEL0_HCLKSEL_PLL)
000012  2d02              CMP      r5,#2
000014  d003              BEQ      |L2.30|
;;;49         {
;;;50             /* Use the clock sources directly */
;;;51             u32Freq = gau32ClkSrcTbl[u32ClkSrc];
000016  00a8              LSLS     r0,r5,#2
000018  490e              LDR      r1,|L2.84|
00001a  580c              LDR      r4,[r1,r0]
00001c  e001              B        |L2.34|
                  |L2.30|
;;;52         }
;;;53         else
;;;54         {
;;;55             /* Use PLL clock */
;;;56             u32Freq = PllClock;
00001e  480c              LDR      r0,|L2.80|
000020  6804              LDR      r4,[r0,#0]  ; PllClock
                  |L2.34|
;;;57         }
;;;58     
;;;59         u32HclkDiv = (CLK->CLKDIV0 & CLK_CLKDIV0_HCLKDIV_Msk) + 1;
000022  480a              LDR      r0,|L2.76|
000024  6a00              LDR      r0,[r0,#0x20]
000026  0700              LSLS     r0,r0,#28
000028  0f00              LSRS     r0,r0,#28
00002a  1c46              ADDS     r6,r0,#1
;;;60     
;;;61         /* Update System Core Clock */
;;;62         SystemCoreClock = u32Freq / u32HclkDiv;
00002c  4631              MOV      r1,r6
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       __aeabi_uidivmod
000034  4908              LDR      r1,|L2.88|
000036  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;63     
;;;64         CyclesPerUs = (SystemCoreClock + 500000) / 1000000;
000038  4908              LDR      r1,|L2.92|
00003a  4807              LDR      r0,|L2.88|
00003c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00003e  104a              ASRS     r2,r1,#1
000040  1880              ADDS     r0,r0,r2
000042  f7fffffe          BL       __aeabi_uidivmod
000046  4906              LDR      r1,|L2.96|
000048  6008              STR      r0,[r1,#0]  ; CyclesPerUs
;;;65     }
00004a  bd70              POP      {r4-r6,pc}
;;;66     
                          ENDP

                  |L2.76|
                          DCD      0x40000200
                  |L2.80|
                          DCD      PllClock
                  |L2.84|
                          DCD      gau32ClkSrcTbl
                  |L2.88|
                          DCD      SystemCoreClock
                  |L2.92|
                          DCD      0x000f4240
                  |L2.96|
                          DCD      CyclesPerUs

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;76      */
;;;77     void SystemInit(void)
000000  bf00              NOP      
000002  bf00              NOP      
000004  bf00              NOP      
                  |L3.6|
000006  2059              MOVS     r0,#0x59
000008  490f              LDR      r1,|L3.72|
00000a  6008              STR      r0,[r1,#0]
00000c  2016              MOVS     r0,#0x16
00000e  6008              STR      r0,[r1,#0]
000010  2088              MOVS     r0,#0x88
000012  6008              STR      r0,[r1,#0]
000014  4608              MOV      r0,r1
000016  6800              LDR      r0,[r0,#0]
000018  2800              CMP      r0,#0
00001a  d0f4              BEQ      |L3.6|
00001c  bf00              NOP      
;;;78     {
;;;79         /* Unlock protected registers */
;;;80         SYS_UnlockReg();
;;;81     
;;;82         /* Set HXTGain Level dependend on HXT Frequency */
;;;83         CLK->PWRCTL = CLK->PWRCTL & ~CLK_PWRCTL_HXTGAIN_Msk;
00001e  480b              LDR      r0,|L3.76|
000020  6800              LDR      r0,[r0,#0]
000022  2107              MOVS     r1,#7
000024  0509              LSLS     r1,r1,#20
000026  4388              BICS     r0,r0,r1
000028  4908              LDR      r1,|L3.76|
00002a  6008              STR      r0,[r1,#0]
;;;84         if ((__HXT >= FREQ_4MHZ) && (__HXT < FREQ_8MHZ))
;;;85         {
;;;86             CLK->PWRCTL |= (1 << CLK_PWRCTL_HXTGAIN_Pos);
;;;87         }
;;;88         else if ((__HXT >= FREQ_8MHZ) && (__HXT < FREQ_12MHZ))
;;;89         {
;;;90             CLK->PWRCTL |= (2 << CLK_PWRCTL_HXTGAIN_Pos);
;;;91         }
;;;92         else if ((__HXT >= FREQ_12MHZ) && (__HXT < FREQ_16MHZ))
;;;93         {
;;;94             CLK->PWRCTL |= (3 << CLK_PWRCTL_HXTGAIN_Pos);
;;;95         }
;;;96         else if ((__HXT >= FREQ_16MHZ) && (__HXT < FREQ_24MHZ))
;;;97         {
;;;98             CLK->PWRCTL |= (4 << CLK_PWRCTL_HXTGAIN_Pos);
;;;99         }
;;;100        else
;;;101        {
;;;102            CLK->PWRCTL |= (7 << CLK_PWRCTL_HXTGAIN_Pos);
00002c  4608              MOV      r0,r1
00002e  6800              LDR      r0,[r0,#0]
000030  2107              MOVS     r1,#7
000032  0509              LSLS     r1,r1,#20
000034  4308              ORRS     r0,r0,r1
000036  4905              LDR      r1,|L3.76|
000038  6008              STR      r0,[r1,#0]
;;;103        }
;;;104    
;;;105        /* Lock protected registers */
;;;106        SYS_LockReg();
00003a  bf00              NOP      
00003c  2000              MOVS     r0,#0
00003e  4902              LDR      r1,|L3.72|
000040  6008              STR      r0,[r1,#0]
000042  bf00              NOP      
;;;107    }
000044  4770              BX       lr
;;;108    
                          ENDP

000046  0000              DCW      0x0000
                  |L3.72|
                          DCD      0x40000100
                  |L3.76|
                          DCD      0x40000200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  gau32ClkSrcTbl
                          DCD      0x01e84800
                          DCD      0x00008000
                          DCD      0x05b8d800
                          DCD      0x00009600
                          DCD      0x02dc6c00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x02dc6c00

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x05b8d800
                  CyclesPerUs
                          DCD      0x00000060
                  PllClock
                          DCD      0x05b8d800

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\Device\\Nuvoton\\M031\\Source\\system_M031Series.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_system_M031Series_c_5d646a67____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_system_M031Series_c_5d646a67____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_system_M031Series_c_5d646a67____REVSH|
#line 402
|__asm___19_system_M031Series_c_5d646a67____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
