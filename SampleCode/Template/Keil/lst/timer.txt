; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\timer.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\timer.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\timer.crf ..\..\..\Library\StdDriver\src\timer.c]
                          THUMB

                          AREA ||i.TIMER_CaptureSelect||, CODE, READONLY, ALIGN=1

                  TIMER_CaptureSelect PROC
;;;341      */
;;;342    void TIMER_CaptureSelect(TIMER_T *timer, uint32_t u32Src)
000000  29ff              CMP      r1,#0xff
;;;343    {
;;;344        if (u32Src == TIMER_CAPTURE_FROM_EXTERNAL)
000002  d105              BNE      |L1.16|
;;;345        {
;;;346            timer->CTL = (timer->CTL & ~(TIMER_CTL_CAPSRC_Msk)) |
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  041b              LSLS     r3,r3,#16
00000a  439a              BICS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
00000e  e00b              B        |L1.40|
                  |L1.16|
;;;347                         (TIMER_CAPSRC_TX_EXT);
;;;348        }
;;;349        else
;;;350        {
;;;351            timer->CTL = (timer->CTL & ~(TIMER_CTL_CAPSRC_Msk)) |
000010  6802              LDR      r2,[r0,#0]
000012  2301              MOVS     r3,#1
000014  041b              LSLS     r3,r3,#16
000016  439a              BICS     r2,r2,r3
000018  18d2              ADDS     r2,r2,r3
00001a  6002              STR      r2,[r0,#0]
;;;352                         (TIMER_CAPSRC_INTERNAL);
;;;353            timer->EXTCTL = (timer->EXTCTL & ~(TIMER_EXTCTL_INTERCAPSEL_Msk)) |
00001c  6942              LDR      r2,[r0,#0x14]
00001e  2307              MOVS     r3,#7
000020  021b              LSLS     r3,r3,#8
000022  439a              BICS     r2,r2,r3
000024  430a              ORRS     r2,r2,r1
000026  6142              STR      r2,[r0,#0x14]
                  |L1.40|
;;;354                            (u32Src);
;;;355        }
;;;356    }
000028  4770              BX       lr
;;;357    
                          ENDP


                          AREA ||i.TIMER_Close||, CODE, READONLY, ALIGN=1

                  TIMER_Close PROC
;;;76       */
;;;77     void TIMER_Close(TIMER_T *timer)
000000  2100              MOVS     r1,#0
;;;78     {
;;;79         timer->CTL = 0;
000002  6001              STR      r1,[r0,#0]
;;;80         timer->EXTCTL = 0;
000004  6141              STR      r1,[r0,#0x14]
;;;81     }
000006  4770              BX       lr
;;;82     
                          ENDP


                          AREA ||i.TIMER_Delay||, CODE, READONLY, ALIGN=2

                  TIMER_Delay PROC
;;;94       */
;;;95     void TIMER_Delay(TIMER_T *timer, uint32_t u32Usec)
000000  b5fe              PUSH     {r1-r7,lr}
;;;96     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;97         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       TIMER_GetModuleClock
00000c  4607              MOV      r7,r0
;;;98         uint32_t u32Prescale = 0, delay = (SystemCoreClock / u32Clk) + 1;
00000e  2000              MOVS     r0,#0
000010  9002              STR      r0,[sp,#8]
000012  4639              MOV      r1,r7
000014  482b              LDR      r0,|L3.196|
000016  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000018  f7fffffe          BL       __aeabi_uidivmod
00001c  1c40              ADDS     r0,r0,#1
00001e  9001              STR      r0,[sp,#4]
;;;99         uint32_t u32Cmpr, u32NsecPerTick;
;;;100    
;;;101        /* Clear current timer configuration */
;;;102        timer->CTL = 0;
000020  2000              MOVS     r0,#0
000022  6028              STR      r0,[r5,#0]
;;;103        timer->EXTCTL = 0;
000024  6168              STR      r0,[r5,#0x14]
;;;104    
;;;105        if(u32Clk <= 1000000)   /* min delay is 1000 us if timer clock source is <= 1 MHz */
000026  4828              LDR      r0,|L3.200|
000028  4287              CMP      r7,r0
00002a  d809              BHI      |L3.64|
;;;106        {
;;;107            if(u32Usec < 1000)
00002c  207d              MOVS     r0,#0x7d
00002e  00c0              LSLS     r0,r0,#3
000030  4284              CMP      r4,r0
000032  d200              BCS      |L3.54|
;;;108                u32Usec = 1000;
000034  4604              MOV      r4,r0
                  |L3.54|
;;;109            if(u32Usec > 1000000)
000036  4824              LDR      r0,|L3.200|
000038  4284              CMP      r4,r0
00003a  d908              BLS      |L3.78|
;;;110                u32Usec = 1000000;
00003c  4604              MOV      r4,r0
00003e  e006              B        |L3.78|
                  |L3.64|
;;;111        }
;;;112        else
;;;113        {
;;;114            if(u32Usec < 100)
000040  2c64              CMP      r4,#0x64
000042  d200              BCS      |L3.70|
;;;115                u32Usec = 100;
000044  2464              MOVS     r4,#0x64
                  |L3.70|
;;;116            if(u32Usec > 1000000)
000046  4820              LDR      r0,|L3.200|
000048  4284              CMP      r4,r0
00004a  d900              BLS      |L3.78|
;;;117                u32Usec = 1000000;
00004c  4604              MOV      r4,r0
                  |L3.78|
;;;118        }
;;;119    
;;;120        if(u32Clk <= 1000000)
00004e  481e              LDR      r0,|L3.200|
000050  4287              CMP      r7,r0
000052  d80f              BHI      |L3.116|
;;;121        {
;;;122            u32Prescale = 0;
000054  2000              MOVS     r0,#0
000056  9002              STR      r0,[sp,#8]
;;;123            u32NsecPerTick = 1000000000 / u32Clk;
000058  4639              MOV      r1,r7
00005a  481c              LDR      r0,|L3.204|
00005c  f7fffffe          BL       __aeabi_uidivmod
000060  9000              STR      r0,[sp,#0]
;;;124            u32Cmpr = (u32Usec * 1000) / u32NsecPerTick;
000062  217d              MOVS     r1,#0x7d
000064  00c9              LSLS     r1,r1,#3
000066  4361              MULS     r1,r4,r1
000068  4608              MOV      r0,r1
00006a  9900              LDR      r1,[sp,#0]
00006c  f7fffffe          BL       __aeabi_uidivmod
000070  4606              MOV      r6,r0
000072  e010              B        |L3.150|
                  |L3.116|
;;;125        }
;;;126        else
;;;127        {
;;;128            u32Cmpr = u32Usec * (u32Clk / 1000000);
000074  4914              LDR      r1,|L3.200|
000076  4638              MOV      r0,r7
000078  f7fffffe          BL       __aeabi_uidivmod
00007c  4606              MOV      r6,r0
00007e  4366              MULS     r6,r4,r6
;;;129            u32Prescale = (u32Cmpr >> 24);  /* for 24 bits CMPDAT */
000080  0e30              LSRS     r0,r6,#24
000082  9002              STR      r0,[sp,#8]
;;;130            if (u32Prescale > 0)
000084  9802              LDR      r0,[sp,#8]
000086  2800              CMP      r0,#0
000088  d005              BEQ      |L3.150|
;;;131                u32Cmpr = u32Cmpr / (u32Prescale + 1);
00008a  9902              LDR      r1,[sp,#8]
00008c  1c49              ADDS     r1,r1,#1
00008e  4630              MOV      r0,r6
000090  f7fffffe          BL       __aeabi_uidivmod
000094  4606              MOV      r6,r0
                  |L3.150|
;;;132        }
;;;133    
;;;134        timer->CMP = u32Cmpr;
000096  606e              STR      r6,[r5,#4]
;;;135        timer->CTL = TIMER_CTL_CNTEN_Msk | TIMER_ONESHOT_MODE | u32Prescale;
000098  2101              MOVS     r1,#1
00009a  0789              LSLS     r1,r1,#30
00009c  9802              LDR      r0,[sp,#8]
00009e  4308              ORRS     r0,r0,r1
0000a0  6028              STR      r0,[r5,#0]
;;;136    
;;;137        /* When system clock is faster than timer clock, it is possible timer active bit cannot set in time while we check it. */
;;;138        /* And the while loop below return immediately, so put a tiny delay here allowing timer start counting and raise active flag. */
;;;139        for(; delay > 0; delay--)
0000a2  e003              B        |L3.172|
                  |L3.164|
;;;140        {
;;;141            __NOP();
0000a4  bf00              NOP      
0000a6  9801              LDR      r0,[sp,#4]            ;139
0000a8  1e40              SUBS     r0,r0,#1              ;139
0000aa  9001              STR      r0,[sp,#4]            ;139
                  |L3.172|
0000ac  9801              LDR      r0,[sp,#4]            ;139
0000ae  2800              CMP      r0,#0                 ;139
0000b0  d1f8              BNE      |L3.164|
;;;142        }
;;;143    
;;;144        while(timer->CTL & TIMER_CTL_ACTSTS_Msk);
0000b2  bf00              NOP      
                  |L3.180|
0000b4  6828              LDR      r0,[r5,#0]
0000b6  2101              MOVS     r1,#1
0000b8  0649              LSLS     r1,r1,#25
0000ba  4008              ANDS     r0,r0,r1
0000bc  2800              CMP      r0,#0
0000be  d1f9              BNE      |L3.180|
;;;145    }
0000c0  bdfe              POP      {r1-r7,pc}
;;;146    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L3.196|
                          DCD      SystemCoreClock
                  |L3.200|
                          DCD      0x000f4240
                  |L3.204|
                          DCD      0x3b9aca00

                          AREA ||i.TIMER_DisableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_DisableCapture PROC
;;;179      */
;;;180    void TIMER_DisableCapture(TIMER_T *timer)
000000  6941              LDR      r1,[r0,#0x14]
;;;181    {
;;;182        timer->EXTCTL &= ~TIMER_EXTCTL_CAPEN_Msk;
000002  2208              MOVS     r2,#8
000004  4391              BICS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;183    }
000008  4770              BX       lr
;;;184    
                          ENDP


                          AREA ||i.TIMER_DisableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableEventCounter PROC
;;;213      */
;;;214    void TIMER_DisableEventCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;215    {
;;;216        timer->CTL &= ~TIMER_CTL_EXTCNTEN_Msk;
000002  2201              MOVS     r2,#1
000004  0612              LSLS     r2,r2,#24
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;217    }
00000a  4770              BX       lr
;;;218    
                          ENDP


                          AREA ||i.TIMER_DisableFreqCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableFreqCounter PROC
;;;289      */
;;;290    void TIMER_DisableFreqCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;291    {
;;;292        timer->CTL &= ~TIMER_CTL_INTRGEN_Msk;
000002  2201              MOVS     r2,#1
000004  0292              LSLS     r2,r2,#10
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;293    }
00000a  4770              BX       lr
;;;294    
                          ENDP


                          AREA ||i.TIMER_EnableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_EnableCapture PROC
;;;164      */
;;;165    void TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge)
000000  b510              PUSH     {r4,lr}
;;;166    {
;;;167        timer->EXTCTL = (timer->EXTCTL & ~(TIMER_EXTCTL_CAPFUNCS_Msk | TIMER_EXTCTL_CAPEDGE_Msk)) |
000002  6943              LDR      r3,[r0,#0x14]
000004  2416              MOVS     r4,#0x16
000006  43a3              BICS     r3,r3,r4
000008  430b              ORRS     r3,r3,r1
00000a  4313              ORRS     r3,r3,r2
00000c  2408              MOVS     r4,#8
00000e  4323              ORRS     r3,r3,r4
000010  6143              STR      r3,[r0,#0x14]
;;;168                        u32CapMode | u32Edge | TIMER_EXTCTL_CAPEN_Msk;
;;;169    }
000012  bd10              POP      {r4,pc}
;;;170    
                          ENDP


                          AREA ||i.TIMER_EnableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_EnableEventCounter PROC
;;;198      */
;;;199    void TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge)
000000  6942              LDR      r2,[r0,#0x14]
;;;200    {
;;;201        timer->EXTCTL = (timer->EXTCTL & ~TIMER_EXTCTL_CNTPHASE_Msk) | u32Edge;
000002  0852              LSRS     r2,r2,#1
000004  0052              LSLS     r2,r2,#1
000006  430a              ORRS     r2,r2,r1
000008  6142              STR      r2,[r0,#0x14]
;;;202        timer->CTL |= TIMER_CTL_EXTCNTEN_Msk;
00000a  6802              LDR      r2,[r0,#0]
00000c  2301              MOVS     r3,#1
00000e  061b              LSLS     r3,r3,#24
000010  431a              ORRS     r2,r2,r3
000012  6002              STR      r2,[r0,#0]
;;;203    }
000014  4770              BX       lr
;;;204    
                          ENDP


                          AREA ||i.TIMER_EnableFreqCounter||, CODE, READONLY, ALIGN=2

                  TIMER_EnableFreqCounter PROC
;;;269      */
;;;270    void TIMER_EnableFreqCounter(TIMER_T *timer, uint32_t u32DropCount, uint32_t u32Timeout, uint32_t u32EnableInt)
000000  b530              PUSH     {r4,r5,lr}
;;;271    {
000002  460c              MOV      r4,r1
;;;272        TIMER_T *t;    /* store the timer base to configure compare value */
;;;273    
;;;274        t = (timer == TIMER0) ? TIMER1 : TIMER3;
000004  4d09              LDR      r5,|L9.44|
000006  42a8              CMP      r0,r5
000008  d102              BNE      |L9.16|
00000a  4d08              LDR      r5,|L9.44|
00000c  3520              ADDS     r5,r5,#0x20
00000e  e000              B        |L9.18|
                  |L9.16|
000010  4d07              LDR      r5,|L9.48|
                  |L9.18|
000012  4629              MOV      r1,r5
;;;275    
;;;276        t->CMP = 0xFFFFFF;
000014  4d07              LDR      r5,|L9.52|
000016  604d              STR      r5,[r1,#4]
;;;277        t->EXTCTL = u32EnableInt ? TIMER_EXTCTL_CAPIEN_Msk : 0;
000018  2b00              CMP      r3,#0
00001a  d001              BEQ      |L9.32|
00001c  2520              MOVS     r5,#0x20
00001e  e000              B        |L9.34|
                  |L9.32|
000020  2500              MOVS     r5,#0
                  |L9.34|
000022  614d              STR      r5,[r1,#0x14]
;;;278        timer->CTL = TIMER_CTL_INTRGEN_Msk | TIMER_CTL_CNTEN_Msk;
000024  4d04              LDR      r5,|L9.56|
000026  6005              STR      r5,[r0,#0]
;;;279    
;;;280        return;
;;;281    }
000028  bd30              POP      {r4,r5,pc}
;;;282    
                          ENDP

00002a  0000              DCW      0x0000
                  |L9.44|
                          DCD      0x40050000
                  |L9.48|
                          DCD      0x40051020
                  |L9.52|
                          DCD      0x00ffffff
                  |L9.56|
                          DCD      0x40000400

                          AREA ||i.TIMER_GetModuleClock||, CODE, READONLY, ALIGN=2

                  TIMER_GetModuleClock PROC
;;;228      */
;;;229    uint32_t TIMER_GetModuleClock(TIMER_T *timer)
000000  b530              PUSH     {r4,r5,lr}
;;;230    {
000002  b089              SUB      sp,sp,#0x24
000004  4604              MOV      r4,r0
;;;231        uint32_t u32Src;
;;;232        const uint32_t au32Clk[] = {__HXT, __LXT, 0, 0, 0, __LIRC, 0, __HIRC};
000006  2220              MOVS     r2,#0x20
000008  491e              LDR      r1,|L10.132|
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       __aeabi_memcpy4
;;;233    
;;;234        if(timer == TIMER0)
000010  481d              LDR      r0,|L10.136|
000012  4284              CMP      r4,r0
000014  d106              BNE      |L10.36|
;;;235            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR0SEL_Msk) >> CLK_CLKSEL1_TMR0SEL_Pos;
000016  481d              LDR      r0,|L10.140|
000018  6940              LDR      r0,[r0,#0x14]
00001a  2107              MOVS     r1,#7
00001c  0209              LSLS     r1,r1,#8
00001e  4008              ANDS     r0,r0,r1
000020  0a05              LSRS     r5,r0,#8
000022  e01a              B        |L10.90|
                  |L10.36|
;;;236        else if(timer == TIMER1)
000024  4818              LDR      r0,|L10.136|
000026  3020              ADDS     r0,r0,#0x20
000028  4284              CMP      r4,r0
00002a  d106              BNE      |L10.58|
;;;237            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR1SEL_Msk) >> CLK_CLKSEL1_TMR1SEL_Pos;
00002c  4817              LDR      r0,|L10.140|
00002e  6940              LDR      r0,[r0,#0x14]
000030  2107              MOVS     r1,#7
000032  0309              LSLS     r1,r1,#12
000034  4008              ANDS     r0,r0,r1
000036  0b05              LSRS     r5,r0,#12
000038  e00f              B        |L10.90|
                  |L10.58|
;;;238        else if(timer == TIMER2)
00003a  4815              LDR      r0,|L10.144|
00003c  4284              CMP      r4,r0
00003e  d106              BNE      |L10.78|
;;;239            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR2SEL_Msk) >> CLK_CLKSEL1_TMR2SEL_Pos;
000040  4812              LDR      r0,|L10.140|
000042  6940              LDR      r0,[r0,#0x14]
000044  2107              MOVS     r1,#7
000046  0409              LSLS     r1,r1,#16
000048  4008              ANDS     r0,r0,r1
00004a  0c05              LSRS     r5,r0,#16
00004c  e005              B        |L10.90|
                  |L10.78|
;;;240        else  /* Timer 3 */
;;;241            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR3SEL_Msk) >> CLK_CLKSEL1_TMR3SEL_Pos;
00004e  480f              LDR      r0,|L10.140|
000050  6940              LDR      r0,[r0,#0x14]
000052  2107              MOVS     r1,#7
000054  0509              LSLS     r1,r1,#20
000056  4008              ANDS     r0,r0,r1
000058  0d05              LSRS     r5,r0,#20
                  |L10.90|
;;;242    
;;;243        if(u32Src == 2)
00005a  2d02              CMP      r5,#2
00005c  d10d              BNE      |L10.122|
;;;244        {
;;;245            if ((timer == TIMER0) || (timer == TIMER1))
00005e  480a              LDR      r0,|L10.136|
000060  4284              CMP      r4,r0
000062  d003              BEQ      |L10.108|
000064  4808              LDR      r0,|L10.136|
000066  3020              ADDS     r0,r0,#0x20
000068  4284              CMP      r4,r0
00006a  d103              BNE      |L10.116|
                  |L10.108|
;;;246                return CLK_GetPCLK0Freq();
00006c  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L10.112|
;;;247            else
;;;248                return CLK_GetPCLK1Freq();
;;;249        }
;;;250    
;;;251        return (au32Clk[u32Src]);
;;;252    }
000070  b009              ADD      sp,sp,#0x24
000072  bd30              POP      {r4,r5,pc}
                  |L10.116|
000074  f7fffffe          BL       CLK_GetPCLK1Freq
000078  e7fa              B        |L10.112|
                  |L10.122|
00007a  00a8              LSLS     r0,r5,#2              ;251
00007c  a901              ADD      r1,sp,#4              ;251
00007e  5808              LDR      r0,[r1,r0]            ;251
000080  e7f6              B        |L10.112|
;;;253    
                          ENDP

000082  0000              DCW      0x0000
                  |L10.132|
                          DCD      ||.constdata||
                  |L10.136|
                          DCD      0x40050000
                  |L10.140|
                          DCD      0x40000200
                  |L10.144|
                          DCD      0x40051000

                          AREA ||i.TIMER_Open||, CODE, READONLY, ALIGN=1

                  TIMER_Open PROC
;;;43       */
;;;44     uint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;45     {
000002  b082              SUB      sp,sp,#8
000004  4606              MOV      r6,r0
000006  4617              MOV      r7,r2
;;;46         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       TIMER_GetModuleClock
00000e  9001              STR      r0,[sp,#4]
;;;47         uint32_t u32Cmpr = 0, u32Prescale = 0;
000010  2400              MOVS     r4,#0
000012  2500              MOVS     r5,#0
;;;48     
;;;49         /* Fastest possible timer working freq is (u32Clk / 2). While cmpr = 2, pre-scale = 0. */
;;;50         if(u32Freq >= (u32Clk >> 1))
000014  9801              LDR      r0,[sp,#4]
000016  0840              LSRS     r0,r0,#1
000018  42b8              CMP      r0,r7
00001a  d801              BHI      |L11.32|
;;;51         {
;;;52             u32Cmpr = 2;
00001c  2402              MOVS     r4,#2
00001e  e00c              B        |L11.58|
                  |L11.32|
;;;53         }
;;;54         else
;;;55         {
;;;56             u32Cmpr = u32Clk / u32Freq;
000020  4639              MOV      r1,r7
000022  9801              LDR      r0,[sp,#4]
000024  f7fffffe          BL       __aeabi_uidivmod
000028  4604              MOV      r4,r0
;;;57             u32Prescale = (u32Cmpr >> 24);  /* for 24 bits CMPDAT */
00002a  0e25              LSRS     r5,r4,#24
;;;58             if (u32Prescale > 0)
00002c  2d00              CMP      r5,#0
00002e  d004              BEQ      |L11.58|
;;;59                 u32Cmpr = u32Cmpr / (u32Prescale + 1);
000030  1c69              ADDS     r1,r5,#1
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       __aeabi_uidivmod
000038  4604              MOV      r4,r0
                  |L11.58|
;;;60         }
;;;61     
;;;62         timer->CTL = u32Mode | u32Prescale;
00003a  9803              LDR      r0,[sp,#0xc]
00003c  4328              ORRS     r0,r0,r5
00003e  6030              STR      r0,[r6,#0]
;;;63         timer->CMP = u32Cmpr;
000040  6074              STR      r4,[r6,#4]
;;;64     
;;;65         return(u32Clk / (u32Cmpr * (u32Prescale + 1)));
000042  1c68              ADDS     r0,r5,#1
000044  4360              MULS     r0,r4,r0
000046  4601              MOV      r1,r0
000048  9801              LDR      r0,[sp,#4]
00004a  f7fffffe          BL       __aeabi_uidivmod
;;;66     }
00004e  b005              ADD      sp,sp,#0x14
000050  bdf0              POP      {r4-r7,pc}
;;;67     
                          ENDP


                          AREA ||i.TIMER_SetTriggerSource||, CODE, READONLY, ALIGN=1

                  TIMER_SetTriggerSource PROC
;;;304      */
;;;305    void TIMER_SetTriggerSource(TIMER_T *timer, uint32_t u32Src)
000000  6802              LDR      r2,[r0,#0]
;;;306    {
;;;307        timer->CTL = (timer->CTL & ~TIMER_CTL_TRGSSEL_Msk) | u32Src;
000002  2301              MOVS     r3,#1
000004  049b              LSLS     r3,r3,#18
000006  439a              BICS     r2,r2,r3
000008  430a              ORRS     r2,r2,r1
00000a  6002              STR      r2,[r0,#0]
;;;308    }
00000c  4770              BX       lr
;;;309    
                          ENDP


                          AREA ||i.TIMER_SetTriggerTarget||, CODE, READONLY, ALIGN=2

                  TIMER_SetTriggerTarget PROC
;;;321      */
;;;322    void TIMER_SetTriggerTarget(TIMER_T *timer, uint32_t u32Mask)
000000  6802              LDR      r2,[r0,#0]
;;;323    {
;;;324        timer->CTL = (timer->CTL & ~(TIMER_CTL_TRGPWM_Msk | TIMER_CTL_TRGADC_Msk | TIMER_CTL_TRGPDMA_Msk | TIMER_CTL_TRGBPWM_Msk)) | (u32Mask);
000002  4b02              LDR      r3,|L13.12|
000004  401a              ANDS     r2,r2,r3
000006  430a              ORRS     r2,r2,r1
000008  6002              STR      r2,[r0,#0]
;;;325    }
00000a  4770              BX       lr
;;;326    
                          ENDP

                  |L13.12|
                          DCD      0xffd7fcff

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x01e84800
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00009600
                          DCD      0x00000000
                          DCD      0x02dc6c00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_timer_c_5bec749a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REVSH|
#line 402
|__asm___7_timer_c_5bec749a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
