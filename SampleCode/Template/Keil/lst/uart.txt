; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\uart.crf ..\..\..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;456      */
;;;457    static __INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;458    {
;;;459        uint32_t u32PllFreq;
;;;460        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;461        uint8_t au8NoTbl[4] = {1, 2, 2, 4}; /* OUTDIV :DEF: {1, 2, 2, 4} */
000002  a01b              ADR      r0,|L1.112|
000004  6800              LDR      r0,[r0,#0]
000006  9000              STR      r0,[sp,#0]
;;;462        uint32_t u32Reg;
;;;463    
;;;464        u32PllFreq = 0;
000008  2000              MOVS     r0,#0
00000a  9002              STR      r0,[sp,#8]
;;;465        u32Reg = CLK->PLLCTL;
00000c  4819              LDR      r0,|L1.116|
00000e  6804              LDR      r4,[r0,#0]
;;;466    
;;;467        if ((u32Reg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk)) == 0)
000010  2005              MOVS     r0,#5
000012  0400              LSLS     r0,r0,#16
000014  4020              ANDS     r0,r0,r4
000016  2800              CMP      r0,#0
000018  d127              BNE      |L1.106|
;;;468        {
;;;469            /* PLL is enabled and output enabled */
;;;470            if (u32Reg & CLK_PLLCTL_PLLSRC_Msk)
00001a  2001              MOVS     r0,#1
00001c  04c0              LSLS     r0,r0,#19
00001e  4020              ANDS     r0,r0,r4
000020  2800              CMP      r0,#0
000022  d001              BEQ      |L1.40|
;;;471            {
;;;472                u32FIN = (__HIRC >> 2);
000024  4d14              LDR      r5,|L1.120|
000026  e000              B        |L1.42|
                  |L1.40|
;;;473            } else
;;;474                u32FIN = __HXT;
000028  4d14              LDR      r5,|L1.124|
                  |L1.42|
;;;475    
;;;476            if (u32Reg & CLK_PLLCTL_BP_Msk)
00002a  2001              MOVS     r0,#1
00002c  0440              LSLS     r0,r0,#17
00002e  4020              ANDS     r0,r0,r4
000030  2800              CMP      r0,#0
000032  d001              BEQ      |L1.56|
;;;477            {
;;;478                /* PLL is in bypass mode */
;;;479                u32PllFreq = u32FIN;
000034  9502              STR      r5,[sp,#8]
000036  e018              B        |L1.106|
                  |L1.56|
;;;480            }
;;;481            else
;;;482            {
;;;483                /* PLL is in normal work mode */
;;;484                u32NO = au8NoTbl[((u32Reg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
000038  2003              MOVS     r0,#3
00003a  0380              LSLS     r0,r0,#14
00003c  4020              ANDS     r0,r0,r4
00003e  0b80              LSRS     r0,r0,#14
000040  4669              MOV      r1,sp
000042  5c0a              LDRB     r2,[r1,r0]
000044  9201              STR      r2,[sp,#4]
;;;485                u32NF  = ((u32Reg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
000046  05e0              LSLS     r0,r4,#23
000048  0dc0              LSRS     r0,r0,#23
00004a  1c86              ADDS     r6,r0,#2
;;;486                u32NR  = ((u32Reg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
00004c  201f              MOVS     r0,#0x1f
00004e  0240              LSLS     r0,r0,#9
000050  4020              ANDS     r0,r0,r4
000052  0a40              LSRS     r0,r0,#9
000054  1c87              ADDS     r7,r0,#2
;;;487                /* u32FIN is shifted 2 bits to avoid overflow */
;;;488                u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
000056  9a01              LDR      r2,[sp,#4]
000058  437a              MULS     r2,r7,r2
00005a  4611              MOV      r1,r2
00005c  08aa              LSRS     r2,r5,#2
00005e  4372              MULS     r2,r6,r2
000060  4610              MOV      r0,r2
000062  f7fffffe          BL       __aeabi_uidivmod
000066  0080              LSLS     r0,r0,#2
000068  9002              STR      r0,[sp,#8]
                  |L1.106|
;;;489            }
;;;490        }
;;;491    
;;;492        return u32PllFreq;
00006a  9802              LDR      r0,[sp,#8]
;;;493    }
00006c  bdfe              POP      {r1-r7,pc}
;;;494    
                          ENDP

00006e  0000              DCW      0x0000
                  |L1.112|
000070  01020204          DCB      1,2,2,4
                  |L1.116|
                          DCD      0x40000240
                  |L1.120|
                          DCD      0x00b71b00
                  |L1.124|
                          DCD      0x01e84800

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=2

                  UART_ClearIntFlag PROC
;;;40     
;;;41     void UART_ClearIntFlag(UART_T *uart , uint32_t u32InterruptFlag)
000000  2201              MOVS     r2,#1
;;;42     {
;;;43     
;;;44     
;;;45         if (u32InterruptFlag & UART_INTSTS_SWBEINT_Msk)   /* Clear Bit Error Detection Interrupt */
000002  0612              LSLS     r2,r2,#24
000004  400a              ANDS     r2,r2,r1
000006  2a00              CMP      r2,#0
000008  d002              BEQ      |L2.16|
;;;46         {
;;;47             uart->INTSTS = UART_INTSTS_SWBEIF_Msk;
00000a  2201              MOVS     r2,#1
00000c  0412              LSLS     r2,r2,#16
00000e  61c2              STR      r2,[r0,#0x1c]
                  |L2.16|
;;;48         }
;;;49     
;;;50         if (u32InterruptFlag & UART_INTSTS_RLSINT_Msk)   /* Clear Receive Line Status Interrupt */
000010  2201              MOVS     r2,#1
000012  0292              LSLS     r2,r2,#10
000014  400a              ANDS     r2,r2,r1
000016  2a00              CMP      r2,#0
000018  d003              BEQ      |L2.34|
;;;51         {
;;;52             uart->FIFOSTS = UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk;
00001a  2270              MOVS     r2,#0x70
00001c  6182              STR      r2,[r0,#0x18]
;;;53             uart->FIFOSTS = UART_FIFOSTS_ADDRDETF_Msk;
00001e  2208              MOVS     r2,#8
000020  6182              STR      r2,[r0,#0x18]
                  |L2.34|
;;;54         }
;;;55     
;;;56         if (u32InterruptFlag & UART_INTSTS_MODEMINT_Msk)   /* Clear Modem Status Interrupt */
000022  2201              MOVS     r2,#1
000024  02d2              LSLS     r2,r2,#11
000026  400a              ANDS     r2,r2,r1
000028  2a00              CMP      r2,#0
00002a  d003              BEQ      |L2.52|
;;;57         {
;;;58             uart->MODEMSTS |= UART_MODEMSTS_CTSDETF_Msk;
00002c  6942              LDR      r2,[r0,#0x14]
00002e  2301              MOVS     r3,#1
000030  431a              ORRS     r2,r2,r3
000032  6142              STR      r2,[r0,#0x14]
                  |L2.52|
;;;59         }
;;;60     
;;;61         if (u32InterruptFlag & UART_INTSTS_BUFERRINT_Msk)   /* Clear Buffer Error Interrupt */
000034  2201              MOVS     r2,#1
000036  0352              LSLS     r2,r2,#13
000038  400a              ANDS     r2,r2,r1
00003a  2a00              CMP      r2,#0
00003c  d001              BEQ      |L2.66|
;;;62         {
;;;63             uart->FIFOSTS = UART_FIFOSTS_RXOVIF_Msk | UART_FIFOSTS_TXOVIF_Msk;
00003e  4a05              LDR      r2,|L2.84|
000040  6182              STR      r2,[r0,#0x18]
                  |L2.66|
;;;64         }
;;;65     
;;;66         if (u32InterruptFlag & UART_INTSTS_WKINT_Msk)   /* Clear Wake-up Interrupt */
000042  2201              MOVS     r2,#1
000044  0392              LSLS     r2,r2,#14
000046  400a              ANDS     r2,r2,r1
000048  2a00              CMP      r2,#0
00004a  d001              BEQ      |L2.80|
;;;67         {
;;;68             uart->WKSTS = UART_WKSTS_CTSWKF_Msk  | UART_WKSTS_DATWKF_Msk  |
00004c  221f              MOVS     r2,#0x1f
00004e  6442              STR      r2,[r0,#0x44]
                  |L2.80|
;;;69                           UART_WKSTS_RFRTWKF_Msk | UART_WKSTS_RS485WKF_Msk |
;;;70                           UART_WKSTS_TOUTWKF_Msk;
;;;71         }
;;;72     
;;;73     }
000050  4770              BX       lr
;;;74     
                          ENDP

000052  0000              DCW      0x0000
                  |L2.84|
                          DCD      0x01000001

                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;84      */
;;;85     void UART_Close(UART_T *uart)
000000  2100              MOVS     r1,#0
;;;86     {
;;;87         uart->INTEN = 0ul;
000002  6041              STR      r1,[r0,#4]
;;;88     }
000004  4770              BX       lr
;;;89     
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;99      */
;;;100    void UART_DisableFlowCtrl(UART_T *uart)
000000  6841              LDR      r1,[r0,#4]
;;;101    {
;;;102        uart->INTEN &= ~(UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk);
000002  2203              MOVS     r2,#3
000004  0312              LSLS     r2,r2,#12
000006  4391              BICS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;103    }
00000a  4770              BX       lr
;;;104    
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=1

                  UART_DisableInt PROC
;;;123     */
;;;124    void UART_DisableInt(UART_T  *uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;125    {
;;;126        /* Disable UART specified interrupt */
;;;127        UART_DISABLE_INT(uart, u32InterruptFlag);
000002  438a              BICS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;128    
;;;129    }
000006  4770              BX       lr
;;;130    
                          ENDP


                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_EnableFlowCtrl PROC
;;;140     */
;;;141    void UART_EnableFlowCtrl(UART_T *uart)
000000  6901              LDR      r1,[r0,#0x10]
;;;142    {
;;;143        /* Set RTS pin output is low level active */
;;;144        uart->MODEM |= UART_MODEM_RTSACTLV_Msk;
000002  2201              MOVS     r2,#1
000004  0252              LSLS     r2,r2,#9
000006  4311              ORRS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;145    
;;;146        /* Set CTS pin input is low level active */
;;;147        uart->MODEMSTS |= UART_MODEMSTS_CTSACTLV_Msk;
00000a  6941              LDR      r1,[r0,#0x14]
00000c  1052              ASRS     r2,r2,#1
00000e  4311              ORRS     r1,r1,r2
000010  6141              STR      r1,[r0,#0x14]
;;;148    
;;;149        /* Set RTS and CTS auto flow control enable */
;;;150        uart->INTEN |= UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk;
000012  6841              LDR      r1,[r0,#4]
000014  2203              MOVS     r2,#3
000016  0312              LSLS     r2,r2,#12
000018  4311              ORRS     r1,r1,r2
00001a  6041              STR      r1,[r0,#4]
;;;151    }
00001c  4770              BX       lr
;;;152    
                          ENDP


                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=1

                  UART_EnableInt PROC
;;;171     */
;;;172    void UART_EnableInt(UART_T  *uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;173    {
;;;174        /* Enable UART specified interrupt */
;;;175        UART_ENABLE_INT(uart, u32InterruptFlag);
000002  430a              ORRS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;176    
;;;177    }
000006  4770              BX       lr
;;;178    
                          ENDP


                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;189     */
;;;190    void UART_Open(UART_T *uart, uint32_t u32baudrate)
000000  b5f0              PUSH     {r4-r7,lr}
;;;191    {
000002  b089              SUB      sp,sp,#0x24
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;192        uint32_t u32UartClkSrcSel = 0ul, u32UartClkDivNum = 0ul;
000008  2500              MOVS     r5,#0
00000a  2700              MOVS     r7,#0
;;;193        uint32_t u32ClkTbl[6ul] = {__HXT, 0ul, __LXT, __HIRC, 0ul, __LIRC};
00000c  2218              MOVS     r2,#0x18
00000e  496a              LDR      r1,|L8.440|
000010  a803              ADD      r0,sp,#0xc
000012  f7fffffe          BL       __aeabi_memcpy4
;;;194        uint32_t u32Baud_Div = 0ul;
000016  2000              MOVS     r0,#0
000018  9002              STR      r0,[sp,#8]
;;;195    
;;;196    
;;;197        if (uart == (UART_T *)UART0)
00001a  4868              LDR      r0,|L8.444|
00001c  4284              CMP      r4,r0
00001e  d10b              BNE      |L8.56|
;;;198        {
;;;199            /* Get UART clock source selection */
;;;200            u32UartClkSrcSel = ((uint32_t)(CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk)) >> CLK_CLKSEL1_UART0SEL_Pos;
000020  4867              LDR      r0,|L8.448|
000022  6940              LDR      r0,[r0,#0x14]
000024  0221              LSLS     r1,r4,#8
000026  4008              ANDS     r0,r0,r1
000028  0e05              LSRS     r5,r0,#24
;;;201            /* Get UART clock divider number */
;;;202            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
00002a  4865              LDR      r0,|L8.448|
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  210f              MOVS     r1,#0xf
000030  0209              LSLS     r1,r1,#8
000032  4008              ANDS     r0,r0,r1
000034  0a07              LSRS     r7,r0,#8
000036  e06b              B        |L8.272|
                  |L8.56|
;;;203        }
;;;204        else if (uart == (UART_T *)UART1)
000038  4862              LDR      r0,|L8.452|
00003a  4284              CMP      r4,r0
00003c  d10c              BNE      |L8.88|
;;;205        {
;;;206            /* Get UART clock source selection */
;;;207            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
00003e  4860              LDR      r0,|L8.448|
000040  6940              LDR      r0,[r0,#0x14]
000042  2107              MOVS     r1,#7
000044  0709              LSLS     r1,r1,#28
000046  4008              ANDS     r0,r0,r1
000048  0f05              LSRS     r5,r0,#28
;;;208            /* Get UART clock divider number */
;;;209            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
00004a  485d              LDR      r0,|L8.448|
00004c  6a00              LDR      r0,[r0,#0x20]
00004e  210f              MOVS     r1,#0xf
000050  0309              LSLS     r1,r1,#12
000052  4008              ANDS     r0,r0,r1
000054  0b07              LSRS     r7,r0,#12
000056  e05b              B        |L8.272|
                  |L8.88|
;;;210        }
;;;211        else if (uart == (UART_T *)UART2)
000058  485b              LDR      r0,|L8.456|
00005a  4284              CMP      r4,r0
00005c  d10a              BNE      |L8.116|
;;;212        {
;;;213            /* Get UART clock source selection */
;;;214            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
00005e  4858              LDR      r0,|L8.448|
000060  69c0              LDR      r0,[r0,#0x1c]
000062  2107              MOVS     r1,#7
000064  0609              LSLS     r1,r1,#24
000066  4008              ANDS     r0,r0,r1
000068  0e05              LSRS     r5,r0,#24
;;;215            /* Get UART clock divider number */
;;;216            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
00006a  4855              LDR      r0,|L8.448|
00006c  6b00              LDR      r0,[r0,#0x30]
00006e  0707              LSLS     r7,r0,#28
000070  0f3f              LSRS     r7,r7,#28
000072  e04d              B        |L8.272|
                  |L8.116|
;;;217        }
;;;218        else if(uart==(UART_T*)UART3)
000074  4855              LDR      r0,|L8.460|
000076  4284              CMP      r4,r0
000078  d10b              BNE      |L8.146|
;;;219        {
;;;220            /* Get UART clock source selection */
;;;221            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART3SEL_Msk) >> CLK_CLKSEL3_UART3SEL_Pos;
00007a  4851              LDR      r0,|L8.448|
00007c  69c0              LDR      r0,[r0,#0x1c]
00007e  2107              MOVS     r1,#7
000080  0709              LSLS     r1,r1,#28
000082  4008              ANDS     r0,r0,r1
000084  0f05              LSRS     r5,r0,#28
;;;222            /* Get UART clock divider number */
;;;223            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART3DIV_Msk) >> CLK_CLKDIV4_UART3DIV_Pos;
000086  484e              LDR      r0,|L8.448|
000088  6b00              LDR      r0,[r0,#0x30]
00008a  21f0              MOVS     r1,#0xf0
00008c  4008              ANDS     r0,r0,r1
00008e  0907              LSRS     r7,r0,#4
000090  e03e              B        |L8.272|
                  |L8.146|
;;;224        }
;;;225        else if(uart==(UART_T*)UART4)
000092  484f              LDR      r0,|L8.464|
000094  4284              CMP      r4,r0
000096  d10c              BNE      |L8.178|
;;;226        {
;;;227            /* Get UART clock source selection */
;;;228            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART4SEL_Msk) >> CLK_CLKSEL3_UART4SEL_Pos;
000098  4849              LDR      r0,|L8.448|
00009a  69c0              LDR      r0,[r0,#0x1c]
00009c  2107              MOVS     r1,#7
00009e  0409              LSLS     r1,r1,#16
0000a0  4008              ANDS     r0,r0,r1
0000a2  0c05              LSRS     r5,r0,#16
;;;229            /* Get UART clock divider number */
;;;230            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART4DIV_Msk) >> CLK_CLKDIV4_UART4DIV_Pos;
0000a4  4846              LDR      r0,|L8.448|
0000a6  6b00              LDR      r0,[r0,#0x30]
0000a8  210f              MOVS     r1,#0xf
0000aa  0209              LSLS     r1,r1,#8
0000ac  4008              ANDS     r0,r0,r1
0000ae  0a07              LSRS     r7,r0,#8
0000b0  e02e              B        |L8.272|
                  |L8.178|
;;;231        }
;;;232        else if(uart==(UART_T*)UART5)
0000b2  4848              LDR      r0,|L8.468|
0000b4  4284              CMP      r4,r0
0000b6  d10c              BNE      |L8.210|
;;;233        {
;;;234            /* Get UART clock source selection */
;;;235            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART5SEL_Msk) >> CLK_CLKSEL3_UART5SEL_Pos;
0000b8  4841              LDR      r0,|L8.448|
0000ba  69c0              LDR      r0,[r0,#0x1c]
0000bc  2107              MOVS     r1,#7
0000be  0509              LSLS     r1,r1,#20
0000c0  4008              ANDS     r0,r0,r1
0000c2  0d05              LSRS     r5,r0,#20
;;;236            /* Get UART clock divider number */
;;;237            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART5DIV_Msk) >> CLK_CLKDIV4_UART5DIV_Pos;
0000c4  483e              LDR      r0,|L8.448|
0000c6  6b00              LDR      r0,[r0,#0x30]
0000c8  210f              MOVS     r1,#0xf
0000ca  0309              LSLS     r1,r1,#12
0000cc  4008              ANDS     r0,r0,r1
0000ce  0b07              LSRS     r7,r0,#12
0000d0  e01e              B        |L8.272|
                  |L8.210|
;;;238        }
;;;239        else if(uart==(UART_T*)UART6)
0000d2  4841              LDR      r0,|L8.472|
0000d4  4284              CMP      r4,r0
0000d6  d10c              BNE      |L8.242|
;;;240        {
;;;241            /* Get UART clock source selection */
;;;242            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART6SEL_Msk) >> CLK_CLKSEL3_UART6SEL_Pos;
0000d8  4839              LDR      r0,|L8.448|
0000da  69c0              LDR      r0,[r0,#0x1c]
0000dc  2107              MOVS     r1,#7
0000de  0209              LSLS     r1,r1,#8
0000e0  4008              ANDS     r0,r0,r1
0000e2  0a05              LSRS     r5,r0,#8
;;;243            /* Get UART clock divider number */
;;;244            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART6DIV_Msk) >> CLK_CLKDIV4_UART6DIV_Pos;
0000e4  4836              LDR      r0,|L8.448|
0000e6  6b00              LDR      r0,[r0,#0x30]
0000e8  210f              MOVS     r1,#0xf
0000ea  0409              LSLS     r1,r1,#16
0000ec  4008              ANDS     r0,r0,r1
0000ee  0c07              LSRS     r7,r0,#16
0000f0  e00e              B        |L8.272|
                  |L8.242|
;;;245        }
;;;246        else if(uart==(UART_T*)UART7)
0000f2  483a              LDR      r0,|L8.476|
0000f4  4284              CMP      r4,r0
0000f6  d10b              BNE      |L8.272|
;;;247        {
;;;248            /* Get UART clock source selection */
;;;249            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART7SEL_Msk) >> CLK_CLKSEL3_UART7SEL_Pos;
0000f8  4831              LDR      r0,|L8.448|
0000fa  69c0              LDR      r0,[r0,#0x1c]
0000fc  2107              MOVS     r1,#7
0000fe  0309              LSLS     r1,r1,#12
000100  4008              ANDS     r0,r0,r1
000102  0b05              LSRS     r5,r0,#12
;;;250            /* Get UART clock divider number */
;;;251            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART7DIV_Msk) >> CLK_CLKDIV4_UART7DIV_Pos;
000104  482e              LDR      r0,|L8.448|
000106  6b00              LDR      r0,[r0,#0x30]
000108  210f              MOVS     r1,#0xf
00010a  0509              LSLS     r1,r1,#20
00010c  4008              ANDS     r0,r0,r1
00010e  0d07              LSRS     r7,r0,#20
                  |L8.272|
;;;252        }    
;;;253    
;;;254        /* Select UART function */
;;;255        uart->FUNCSEL = UART_FUNCSEL_UART;
000110  2000              MOVS     r0,#0
000112  6320              STR      r0,[r4,#0x30]
;;;256    
;;;257        /* Set UART line configuration */
;;;258        uart->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
000114  2003              MOVS     r0,#3
000116  60e0              STR      r0,[r4,#0xc]
;;;259    
;;;260        /* Set UART Rx and RTS trigger level */
;;;261        uart->FIFO &= ~(UART_FIFO_RFITL_Msk | UART_FIFO_RTSTRGLV_Msk);
000118  68a0              LDR      r0,[r4,#8]
00011a  4931              LDR      r1,|L8.480|
00011c  4008              ANDS     r0,r0,r1
00011e  60a0              STR      r0,[r4,#8]
;;;262    
;;;263        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;264        if (u32UartClkSrcSel == 1ul)
000120  2d01              CMP      r5,#1
000122  d104              BNE      |L8.302|
;;;265        {
;;;266            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
000124  f7fffffe          BL       CLK_GetPLLClockFreq
000128  00a9              LSLS     r1,r5,#2
00012a  aa03              ADD      r2,sp,#0xc
00012c  5050              STR      r0,[r2,r1]
                  |L8.302|
;;;267        }
;;;268    
;;;269        /* Get PCLK clock frequency if UART clock source selection is PCLK */
;;;270        if (u32UartClkSrcSel == 4ul)
00012e  2d04              CMP      r5,#4
000130  d116              BNE      |L8.352|
;;;271        {
;;;272            /* UART Port as UART0 ,UART2, UART4 or UART6 */
;;;273            if ((uart == (UART_T *)UART0) || (uart == (UART_T *)UART2) || (uart == (UART_T *)UART4) || (uart == (UART_T *)UART6))
000132  4822              LDR      r0,|L8.444|
000134  4284              CMP      r4,r0
000136  d008              BEQ      |L8.330|
000138  4823              LDR      r0,|L8.456|
00013a  4284              CMP      r4,r0
00013c  d005              BEQ      |L8.330|
00013e  4824              LDR      r0,|L8.464|
000140  4284              CMP      r4,r0
000142  d002              BEQ      |L8.330|
000144  4824              LDR      r0,|L8.472|
000146  4284              CMP      r4,r0
000148  d105              BNE      |L8.342|
                  |L8.330|
;;;274            {
;;;275                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK0Freq();
00014a  f7fffffe          BL       CLK_GetPCLK0Freq
00014e  00a9              LSLS     r1,r5,#2
000150  aa03              ADD      r2,sp,#0xc
000152  5050              STR      r0,[r2,r1]
000154  e004              B        |L8.352|
                  |L8.342|
;;;276            }
;;;277            else     /* UART Port as UART1, UART3, UART5 or UART7*/
;;;278            {
;;;279                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK1Freq();
000156  f7fffffe          BL       CLK_GetPCLK1Freq
00015a  00a9              LSLS     r1,r5,#2
00015c  aa03              ADD      r2,sp,#0xc
00015e  5050              STR      r0,[r2,r1]
                  |L8.352|
;;;280            }
;;;281    
;;;282        }
;;;283    
;;;284        /* Set UART baud rate */
;;;285        if (u32baudrate != 0ul)
000160  2e00              CMP      r6,#0
000162  d026              BEQ      |L8.434|
;;;286        {
;;;287            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate);
000164  00a9              LSLS     r1,r5,#2
000166  aa03              ADD      r2,sp,#0xc
000168  5850              LDR      r0,[r2,r1]
00016a  1c79              ADDS     r1,r7,#1
00016c  f7fffffe          BL       __aeabi_uidivmod
000170  0871              LSRS     r1,r6,#1
000172  1840              ADDS     r0,r0,r1
000174  4631              MOV      r1,r6
000176  9001              STR      r0,[sp,#4]
000178  f7fffffe          BL       __aeabi_uidivmod
00017c  1e80              SUBS     r0,r0,#2
00017e  9002              STR      r0,[sp,#8]
;;;288    
;;;289            if (u32Baud_Div > 0xFFFFul)
000180  4918              LDR      r1,|L8.484|
000182  9802              LDR      r0,[sp,#8]
000184  4288              CMP      r0,r1
000186  d90f              BLS      |L8.424|
;;;290            {
;;;291                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate));
000188  00a9              LSLS     r1,r5,#2
00018a  aa03              ADD      r2,sp,#0xc
00018c  5850              LDR      r0,[r2,r1]
00018e  1c79              ADDS     r1,r7,#1
000190  f7fffffe          BL       __aeabi_uidivmod
000194  00f1              LSLS     r1,r6,#3
000196  1840              ADDS     r0,r0,r1
000198  4631              MOV      r1,r6
00019a  9001              STR      r0,[sp,#4]
00019c  f7fffffe          BL       __aeabi_uidivmod
0001a0  0900              LSRS     r0,r0,#4
0001a2  1e80              SUBS     r0,r0,#2
0001a4  6260              STR      r0,[r4,#0x24]
0001a6  e004              B        |L8.434|
                  |L8.424|
;;;292            }
;;;293            else
;;;294            {
;;;295                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
0001a8  2103              MOVS     r1,#3
0001aa  0709              LSLS     r1,r1,#28
0001ac  9802              LDR      r0,[sp,#8]
0001ae  4308              ORRS     r0,r0,r1
0001b0  6260              STR      r0,[r4,#0x24]
                  |L8.434|
;;;296            }
;;;297        }
;;;298    }
0001b2  b009              ADD      sp,sp,#0x24
0001b4  bdf0              POP      {r4-r7,pc}
;;;299    
                          ENDP

0001b6  0000              DCW      0x0000
                  |L8.440|
                          DCD      ||.constdata||
                  |L8.444|
                          DCD      0x40070000
                  |L8.448|
                          DCD      0x40000200
                  |L8.452|
                          DCD      0x40071000
                  |L8.456|
                          DCD      0x40072000
                  |L8.460|
                          DCD      0x40073000
                  |L8.464|
                          DCD      0x40074000
                  |L8.468|
                          DCD      0x40075000
                  |L8.472|
                          DCD      0x40076000
                  |L8.476|
                          DCD      0x40077000
                  |L8.480|
                          DCD      0xfff0ff0f
                  |L8.484|
                          DCD      0x0000ffff

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;311     */
;;;312    uint32_t UART_Read(UART_T *uart, uint8_t pu8RxBuf[], uint32_t u32ReadBytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;313    {
000002  4603              MOV      r3,r0
;;;314        uint32_t  u32Count, u32delayno;
;;;315        uint32_t  u32Exit = 0ul;
000004  2500              MOVS     r5,#0
;;;316    
;;;317        for (u32Count = 0ul; u32Count < u32ReadBytes; u32Count++)
000006  2000              MOVS     r0,#0
000008  e015              B        |L9.54|
                  |L9.10|
;;;318        {
;;;319            u32delayno = 0ul;
00000a  2400              MOVS     r4,#0
;;;320    
;;;321            while (uart->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk)   /* Check RX empty => failed */
00000c  e006              B        |L9.28|
                  |L9.14|
;;;322            {
;;;323                u32delayno++;
00000e  1c64              ADDS     r4,r4,#1
;;;324    
;;;325                if (u32delayno >= 0x40000000ul)
000010  2601              MOVS     r6,#1
000012  07b6              LSLS     r6,r6,#30
000014  42b4              CMP      r4,r6
000016  d301              BCC      |L9.28|
;;;326                {
;;;327                    u32Exit = 1ul;
000018  2501              MOVS     r5,#1
;;;328                    break;
00001a  e005              B        |L9.40|
                  |L9.28|
00001c  699e              LDR      r6,[r3,#0x18]         ;321
00001e  2701              MOVS     r7,#1                 ;321
000020  03bf              LSLS     r7,r7,#14             ;321
000022  403e              ANDS     r6,r6,r7              ;321
000024  2e00              CMP      r6,#0                 ;321
000026  d1f2              BNE      |L9.14|
                  |L9.40|
000028  bf00              NOP      
;;;329                }
;;;330            }
;;;331    
;;;332            if (u32Exit == 1ul)
00002a  2d01              CMP      r5,#1
00002c  d100              BNE      |L9.48|
;;;333            {
;;;334                break;
00002e  e004              B        |L9.58|
                  |L9.48|
;;;335            }
;;;336            else
;;;337            {
;;;338                pu8RxBuf[u32Count] = (uint8_t)uart->DAT; /* Get Data from UART RX  */
000030  681e              LDR      r6,[r3,#0]
000032  540e              STRB     r6,[r1,r0]
000034  1c40              ADDS     r0,r0,#1              ;317
                  |L9.54|
000036  4290              CMP      r0,r2                 ;317
000038  d3e7              BCC      |L9.10|
                  |L9.58|
00003a  bf00              NOP                            ;334
;;;339            }
;;;340        }
;;;341    
;;;342        return u32Count;
;;;343    
;;;344    }
00003c  bdf0              POP      {r4-r7,pc}
;;;345    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=2

                  UART_SelectIrDAMode PROC
;;;509     */
;;;510    void UART_SelectIrDAMode(UART_T *uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;511    {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;512        uint32_t u32UartClkSrcSel = 0ul, u32UartClkDivNum = 0ul;
000008  2500              MOVS     r5,#0
00000a  2000              MOVS     r0,#0
00000c  9007              STR      r0,[sp,#0x1c]
;;;513        uint32_t u32ClkTbl[6ul] = {__HXT, 0ul, __LXT, __HIRC, 0ul, __LIRC};
00000e  2218              MOVS     r2,#0x18
000010  4969              LDR      r1,|L10.440|
000012  a801              ADD      r0,sp,#4
000014  f7fffffe          BL       __aeabi_memcpy4
;;;514        uint32_t u32Baud_Div;
;;;515    
;;;516        /* Select IrDA function mode */
;;;517        uart->FUNCSEL = UART_FUNCSEL_IrDA;
000018  2002              MOVS     r0,#2
00001a  6320              STR      r0,[r4,#0x30]
;;;518    
;;;519    
;;;520        if (uart == UART0)
00001c  4867              LDR      r0,|L10.444|
00001e  4284              CMP      r4,r0
000020  d10c              BNE      |L10.60|
;;;521        {
;;;522            /* Get UART clock source selection */
;;;523            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
000022  4867              LDR      r0,|L10.448|
000024  6940              LDR      r0,[r0,#0x14]
000026  0221              LSLS     r1,r4,#8
000028  4008              ANDS     r0,r0,r1
00002a  0e05              LSRS     r5,r0,#24
;;;524            /* Get UART clock divider number */
;;;525            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
00002c  4864              LDR      r0,|L10.448|
00002e  6a00              LDR      r0,[r0,#0x20]
000030  210f              MOVS     r1,#0xf
000032  0209              LSLS     r1,r1,#8
000034  4008              ANDS     r0,r0,r1
000036  0a00              LSRS     r0,r0,#8
000038  9007              STR      r0,[sp,#0x1c]
00003a  e072              B        |L10.290|
                  |L10.60|
;;;526        }
;;;527        else if (uart == UART1)
00003c  4861              LDR      r0,|L10.452|
00003e  4284              CMP      r4,r0
000040  d10d              BNE      |L10.94|
;;;528        {
;;;529            /* Get UART clock source selection */
;;;530            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
000042  485f              LDR      r0,|L10.448|
000044  6940              LDR      r0,[r0,#0x14]
000046  2107              MOVS     r1,#7
000048  0709              LSLS     r1,r1,#28
00004a  4008              ANDS     r0,r0,r1
00004c  0f05              LSRS     r5,r0,#28
;;;531            /* Get UART clock divider number */
;;;532            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
00004e  485c              LDR      r0,|L10.448|
000050  6a00              LDR      r0,[r0,#0x20]
000052  210f              MOVS     r1,#0xf
000054  0309              LSLS     r1,r1,#12
000056  4008              ANDS     r0,r0,r1
000058  0b00              LSRS     r0,r0,#12
00005a  9007              STR      r0,[sp,#0x1c]
00005c  e061              B        |L10.290|
                  |L10.94|
;;;533        }
;;;534        else if (uart == UART2)
00005e  485a              LDR      r0,|L10.456|
000060  4284              CMP      r4,r0
000062  d10b              BNE      |L10.124|
;;;535        {
;;;536            /* Get UART clock source selection */
;;;537            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
000064  4856              LDR      r0,|L10.448|
000066  69c0              LDR      r0,[r0,#0x1c]
000068  2107              MOVS     r1,#7
00006a  0609              LSLS     r1,r1,#24
00006c  4008              ANDS     r0,r0,r1
00006e  0e05              LSRS     r5,r0,#24
;;;538            /* Get UART clock divider number */
;;;539            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
000070  4853              LDR      r0,|L10.448|
000072  6b00              LDR      r0,[r0,#0x30]
000074  0700              LSLS     r0,r0,#28
000076  0f00              LSRS     r0,r0,#28
000078  9007              STR      r0,[sp,#0x1c]
00007a  e052              B        |L10.290|
                  |L10.124|
;;;540        }
;;;541        else if (uart == UART3)
00007c  4853              LDR      r0,|L10.460|
00007e  4284              CMP      r4,r0
000080  d10c              BNE      |L10.156|
;;;542        {
;;;543            /* Get UART clock source selection */
;;;544            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART3SEL_Msk) >> CLK_CLKSEL3_UART3SEL_Pos;
000082  484f              LDR      r0,|L10.448|
000084  69c0              LDR      r0,[r0,#0x1c]
000086  2107              MOVS     r1,#7
000088  0709              LSLS     r1,r1,#28
00008a  4008              ANDS     r0,r0,r1
00008c  0f05              LSRS     r5,r0,#28
;;;545            /* Get UART clock divider number */
;;;546            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART3DIV_Msk) >> CLK_CLKDIV4_UART3DIV_Pos;
00008e  484c              LDR      r0,|L10.448|
000090  6b00              LDR      r0,[r0,#0x30]
000092  21f0              MOVS     r1,#0xf0
000094  4008              ANDS     r0,r0,r1
000096  0900              LSRS     r0,r0,#4
000098  9007              STR      r0,[sp,#0x1c]
00009a  e042              B        |L10.290|
                  |L10.156|
;;;547        }
;;;548        else if (uart == UART4)
00009c  484c              LDR      r0,|L10.464|
00009e  4284              CMP      r4,r0
0000a0  d10d              BNE      |L10.190|
;;;549        {
;;;550            /* Get UART clock source selection */
;;;551            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART4SEL_Msk) >> CLK_CLKSEL3_UART4SEL_Pos;
0000a2  4847              LDR      r0,|L10.448|
0000a4  69c0              LDR      r0,[r0,#0x1c]
0000a6  2107              MOVS     r1,#7
0000a8  0409              LSLS     r1,r1,#16
0000aa  4008              ANDS     r0,r0,r1
0000ac  0c05              LSRS     r5,r0,#16
;;;552            /* Get UART clock divider number */
;;;553            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART4DIV_Msk) >> CLK_CLKDIV4_UART4DIV_Pos;
0000ae  4844              LDR      r0,|L10.448|
0000b0  6b00              LDR      r0,[r0,#0x30]
0000b2  210f              MOVS     r1,#0xf
0000b4  0209              LSLS     r1,r1,#8
0000b6  4008              ANDS     r0,r0,r1
0000b8  0a00              LSRS     r0,r0,#8
0000ba  9007              STR      r0,[sp,#0x1c]
0000bc  e031              B        |L10.290|
                  |L10.190|
;;;554        }
;;;555        else if (uart == UART5)
0000be  4845              LDR      r0,|L10.468|
0000c0  4284              CMP      r4,r0
0000c2  d10d              BNE      |L10.224|
;;;556        {
;;;557            /* Get UART clock source selection */
;;;558            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART5SEL_Msk) >> CLK_CLKSEL3_UART5SEL_Pos;
0000c4  483e              LDR      r0,|L10.448|
0000c6  69c0              LDR      r0,[r0,#0x1c]
0000c8  2107              MOVS     r1,#7
0000ca  0509              LSLS     r1,r1,#20
0000cc  4008              ANDS     r0,r0,r1
0000ce  0d05              LSRS     r5,r0,#20
;;;559            /* Get UART clock divider number */
;;;560            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART5DIV_Msk) >> CLK_CLKDIV4_UART5DIV_Pos;
0000d0  483b              LDR      r0,|L10.448|
0000d2  6b00              LDR      r0,[r0,#0x30]
0000d4  210f              MOVS     r1,#0xf
0000d6  0309              LSLS     r1,r1,#12
0000d8  4008              ANDS     r0,r0,r1
0000da  0b00              LSRS     r0,r0,#12
0000dc  9007              STR      r0,[sp,#0x1c]
0000de  e020              B        |L10.290|
                  |L10.224|
;;;561        }
;;;562        else if (uart == UART6)
0000e0  483d              LDR      r0,|L10.472|
0000e2  4284              CMP      r4,r0
0000e4  d10d              BNE      |L10.258|
;;;563        {
;;;564            /* Get UART clock source selection */
;;;565            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART6SEL_Msk) >> CLK_CLKSEL3_UART6SEL_Pos;
0000e6  4836              LDR      r0,|L10.448|
0000e8  69c0              LDR      r0,[r0,#0x1c]
0000ea  2107              MOVS     r1,#7
0000ec  0209              LSLS     r1,r1,#8
0000ee  4008              ANDS     r0,r0,r1
0000f0  0a05              LSRS     r5,r0,#8
;;;566            /* Get UART clock divider number */
;;;567            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART6DIV_Msk) >> CLK_CLKDIV4_UART6DIV_Pos;
0000f2  4833              LDR      r0,|L10.448|
0000f4  6b00              LDR      r0,[r0,#0x30]
0000f6  210f              MOVS     r1,#0xf
0000f8  0409              LSLS     r1,r1,#16
0000fa  4008              ANDS     r0,r0,r1
0000fc  0c00              LSRS     r0,r0,#16
0000fe  9007              STR      r0,[sp,#0x1c]
000100  e00f              B        |L10.290|
                  |L10.258|
;;;568        }    
;;;569        else if (uart == UART7)
000102  4836              LDR      r0,|L10.476|
000104  4284              CMP      r4,r0
000106  d10c              BNE      |L10.290|
;;;570        {
;;;571            /* Get UART clock source selection */
;;;572            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART7SEL_Msk) >> CLK_CLKSEL3_UART7SEL_Pos;
000108  482d              LDR      r0,|L10.448|
00010a  69c0              LDR      r0,[r0,#0x1c]
00010c  2107              MOVS     r1,#7
00010e  0309              LSLS     r1,r1,#12
000110  4008              ANDS     r0,r0,r1
000112  0b05              LSRS     r5,r0,#12
;;;573            /* Get UART clock divider number */
;;;574            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART7DIV_Msk) >> CLK_CLKDIV4_UART7DIV_Pos;
000114  482a              LDR      r0,|L10.448|
000116  6b00              LDR      r0,[r0,#0x30]
000118  210f              MOVS     r1,#0xf
00011a  0509              LSLS     r1,r1,#20
00011c  4008              ANDS     r0,r0,r1
00011e  0d00              LSRS     r0,r0,#20
000120  9007              STR      r0,[sp,#0x1c]
                  |L10.290|
;;;575        }    
;;;576    
;;;577        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;578        if (u32UartClkSrcSel == 1ul)
000122  2d01              CMP      r5,#1
000124  d104              BNE      |L10.304|
;;;579        {
;;;580            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
000126  f7fffffe          BL       CLK_GetPLLClockFreq
00012a  00a9              LSLS     r1,r5,#2
00012c  aa01              ADD      r2,sp,#4
00012e  5050              STR      r0,[r2,r1]
                  |L10.304|
;;;581        }
;;;582    
;;;583        /* Get PCLK clock frequency if UART clock source selection is PCLK */
;;;584        if (u32UartClkSrcSel == 4ul)
000130  2d04              CMP      r5,#4
000132  d116              BNE      |L10.354|
;;;585        {
;;;586            if ((uart == (UART_T *)UART0) || (uart == (UART_T *)UART2)|| (uart == (UART_T *)UART4)|| (uart == (UART_T *)UART6))
000134  4821              LDR      r0,|L10.444|
000136  4284              CMP      r4,r0
000138  d008              BEQ      |L10.332|
00013a  4823              LDR      r0,|L10.456|
00013c  4284              CMP      r4,r0
00013e  d005              BEQ      |L10.332|
000140  4823              LDR      r0,|L10.464|
000142  4284              CMP      r4,r0
000144  d002              BEQ      |L10.332|
000146  4824              LDR      r0,|L10.472|
000148  4284              CMP      r4,r0
00014a  d105              BNE      |L10.344|
                  |L10.332|
;;;587            {
;;;588                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK0Freq();
00014c  f7fffffe          BL       CLK_GetPCLK0Freq
000150  00a9              LSLS     r1,r5,#2
000152  aa01              ADD      r2,sp,#4
000154  5050              STR      r0,[r2,r1]
000156  e004              B        |L10.354|
                  |L10.344|
;;;589            }
;;;590            else     /* UART Port as UART1, UART3, UART5, UART7*/
;;;591            {
;;;592                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK1Freq();
000158  f7fffffe          BL       CLK_GetPCLK1Freq
00015c  00a9              LSLS     r1,r5,#2
00015e  aa01              ADD      r2,sp,#4
000160  5050              STR      r0,[r2,r1]
                  |L10.354|
;;;593            }
;;;594        }
;;;595    
;;;596    
;;;597        /* Set UART IrDA baud rate in mode 0 */
;;;598        if (u32Buadrate != 0ul)
000162  2f00              CMP      r7,#0
000164  d012              BEQ      |L10.396|
;;;599        {
;;;600            u32Baud_Div = UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32Buadrate);
000166  00a9              LSLS     r1,r5,#2
000168  aa01              ADD      r2,sp,#4
00016a  5850              LDR      r0,[r2,r1]
00016c  9907              LDR      r1,[sp,#0x1c]
00016e  1c49              ADDS     r1,r1,#1
000170  f7fffffe          BL       __aeabi_uidivmod
000174  00f9              LSLS     r1,r7,#3
000176  1840              ADDS     r0,r0,r1
000178  4639              MOV      r1,r7
00017a  9000              STR      r0,[sp,#0]
00017c  f7fffffe          BL       __aeabi_uidivmod
000180  0900              LSRS     r0,r0,#4
000182  1e86              SUBS     r6,r0,#2
;;;601    
;;;602            if (u32Baud_Div < 0xFFFFul)
000184  4816              LDR      r0,|L10.480|
000186  4286              CMP      r6,r0
000188  d200              BCS      |L10.396|
;;;603            {
;;;604                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
00018a  6266              STR      r6,[r4,#0x24]
                  |L10.396|
;;;605            }
;;;606            else
;;;607            {
;;;608            }
;;;609        }
;;;610    
;;;611        /* Configure IrDA relative settings */
;;;612        if (u32Direction == UART_IRDA_RXEN)
00018c  980a              LDR      r0,[sp,#0x28]
00018e  2800              CMP      r0,#0
000190  d108              BNE      |L10.420|
;;;613        {
;;;614            uart->IRDA |= UART_IRDA_RXINV_Msk;     /*Rx signal is inverse*/
000192  6aa0              LDR      r0,[r4,#0x28]
000194  2140              MOVS     r1,#0x40
000196  4308              ORRS     r0,r0,r1
000198  62a0              STR      r0,[r4,#0x28]
;;;615            uart->IRDA &= ~UART_IRDA_TXEN_Msk;
00019a  6aa0              LDR      r0,[r4,#0x28]
00019c  2102              MOVS     r1,#2
00019e  4388              BICS     r0,r0,r1
0001a0  62a0              STR      r0,[r4,#0x28]
0001a2  e007              B        |L10.436|
                  |L10.420|
;;;616        }
;;;617        else
;;;618        {
;;;619            uart->IRDA &= ~UART_IRDA_TXINV_Msk;    /*Tx signal is not inverse*/
0001a4  6aa0              LDR      r0,[r4,#0x28]
0001a6  2120              MOVS     r1,#0x20
0001a8  4388              BICS     r0,r0,r1
0001aa  62a0              STR      r0,[r4,#0x28]
;;;620            uart->IRDA |= UART_IRDA_TXEN_Msk;
0001ac  6aa0              LDR      r0,[r4,#0x28]
0001ae  2102              MOVS     r1,#2
0001b0  4308              ORRS     r0,r0,r1
0001b2  62a0              STR      r0,[r4,#0x28]
                  |L10.436|
;;;621        }
;;;622    
;;;623    }
0001b4  b00b              ADD      sp,sp,#0x2c
0001b6  bdf0              POP      {r4-r7,pc}
;;;624    
                          ENDP

                  |L10.440|
                          DCD      ||.constdata||+0x30
                  |L10.444|
                          DCD      0x40070000
                  |L10.448|
                          DCD      0x40000200
                  |L10.452|
                          DCD      0x40071000
                  |L10.456|
                          DCD      0x40072000
                  |L10.460|
                          DCD      0x40073000
                  |L10.464|
                          DCD      0x40074000
                  |L10.468|
                          DCD      0x40075000
                  |L10.472|
                          DCD      0x40076000
                  |L10.476|
                          DCD      0x40077000
                  |L10.480|
                          DCD      0x0000ffff

                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=2

                  UART_SelectRS485Mode PROC
;;;639     */
;;;640    void UART_SelectRS485Mode(UART_T *uart, uint32_t u32Mode, uint32_t u32Addr)
000000  b510              PUSH     {r4,lr}
;;;641    {
;;;642        /* Select UART RS485 function mode */
;;;643        uart->FUNCSEL = UART_FUNCSEL_RS485;
000002  2303              MOVS     r3,#3
000004  6303              STR      r3,[r0,#0x30]
;;;644    
;;;645        /* Set RS485 configuration */
;;;646        uart->ALTCTL &= ~(UART_ALTCTL_RS485NMM_Msk | UART_ALTCTL_RS485AUD_Msk | UART_ALTCTL_RS485AAD_Msk | UART_ALTCTL_ADDRMV_Msk);
000006  6ac3              LDR      r3,[r0,#0x2c]
000008  4c04              LDR      r4,|L11.28|
00000a  4023              ANDS     r3,r3,r4
00000c  62c3              STR      r3,[r0,#0x2c]
;;;647        uart->ALTCTL |= (u32Mode | (u32Addr << UART_ALTCTL_ADDRMV_Pos));
00000e  6ac3              LDR      r3,[r0,#0x2c]
000010  0614              LSLS     r4,r2,#24
000012  430c              ORRS     r4,r4,r1
000014  4323              ORRS     r3,r3,r4
000016  62c3              STR      r3,[r0,#0x2c]
;;;648    }
000018  bd10              POP      {r4,pc}
;;;649    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x00fff8ff

                          AREA ||i.UART_SelectSingleWireMode||, CODE, READONLY, ALIGN=1

                  UART_SelectSingleWireMode PROC
;;;703     */
;;;704    void UART_SelectSingleWireMode(UART_T *uart)
000000  6b01              LDR      r1,[r0,#0x30]
;;;705    {
;;;706    
;;;707        /* Select UART SingleWire function mode */
;;;708        uart->FUNCSEL = ((uart->FUNCSEL & (~UART_FUNCSEL_FUNCSEL_Msk)) | UART_FUNCSEL_SINGLE_WIRE);
000002  08c9              LSRS     r1,r1,#3
000004  00c9              LSLS     r1,r1,#3
000006  1d09              ADDS     r1,r1,#4
000008  6301              STR      r1,[r0,#0x30]
;;;709    
;;;710    }
00000a  4770              BX       lr
;;;711    
                          ENDP


                          AREA ||i.UART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UART_SetLine_Config PROC
;;;372     */
;;;373    void UART_SetLine_Config(UART_T *uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  b5ff              PUSH     {r0-r7,lr}
;;;374    {
000002  b089              SUB      sp,sp,#0x24
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;375        uint32_t u32UartClkSrcSel = 0ul, u32UartClkDivNum = 0ul;
00000a  2500              MOVS     r5,#0
00000c  2000              MOVS     r0,#0
00000e  9008              STR      r0,[sp,#0x20]
;;;376        uint32_t u32ClkTbl[6ul] = {__HXT, 0ul, __LXT, __HIRC, 0, __LIRC};
000010  2218              MOVS     r2,#0x18
000012  496e              LDR      r1,|L13.460|
000014  a802              ADD      r0,sp,#8
000016  f7fffffe          BL       __aeabi_memcpy4
;;;377        uint32_t u32Baud_Div = 0ul;
00001a  2000              MOVS     r0,#0
00001c  9001              STR      r0,[sp,#4]
;;;378    
;;;379    
;;;380        if (uart == (UART_T *)UART0)
00001e  486c              LDR      r0,|L13.464|
000020  4284              CMP      r4,r0
000022  d10c              BNE      |L13.62|
;;;381        {
;;;382            /* Get UART clock source selection */
;;;383            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
000024  486b              LDR      r0,|L13.468|
000026  6940              LDR      r0,[r0,#0x14]
000028  0221              LSLS     r1,r4,#8
00002a  4008              ANDS     r0,r0,r1
00002c  0e05              LSRS     r5,r0,#24
;;;384            /* Get UART clock divider number */
;;;385            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
00002e  4869              LDR      r0,|L13.468|
000030  6a00              LDR      r0,[r0,#0x20]
000032  210f              MOVS     r1,#0xf
000034  0209              LSLS     r1,r1,#8
000036  4008              ANDS     r0,r0,r1
000038  0a00              LSRS     r0,r0,#8
00003a  9008              STR      r0,[sp,#0x20]
00003c  e072              B        |L13.292|
                  |L13.62|
;;;386        }
;;;387        else if (uart == (UART_T *)UART1)
00003e  4866              LDR      r0,|L13.472|
000040  4284              CMP      r4,r0
000042  d10d              BNE      |L13.96|
;;;388        {
;;;389            /* Get UART clock source selection */
;;;390            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
000044  4863              LDR      r0,|L13.468|
000046  6940              LDR      r0,[r0,#0x14]
000048  2107              MOVS     r1,#7
00004a  0709              LSLS     r1,r1,#28
00004c  4008              ANDS     r0,r0,r1
00004e  0f05              LSRS     r5,r0,#28
;;;391            /* Get UART clock divider number */
;;;392            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
000050  4860              LDR      r0,|L13.468|
000052  6a00              LDR      r0,[r0,#0x20]
000054  210f              MOVS     r1,#0xf
000056  0309              LSLS     r1,r1,#12
000058  4008              ANDS     r0,r0,r1
00005a  0b00              LSRS     r0,r0,#12
00005c  9008              STR      r0,[sp,#0x20]
00005e  e061              B        |L13.292|
                  |L13.96|
;;;393        }
;;;394        else if (uart == (UART_T *)UART2)
000060  485e              LDR      r0,|L13.476|
000062  4284              CMP      r4,r0
000064  d10b              BNE      |L13.126|
;;;395        {
;;;396            /* Get UART clock source selection */
;;;397            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
000066  485b              LDR      r0,|L13.468|
000068  69c0              LDR      r0,[r0,#0x1c]
00006a  2107              MOVS     r1,#7
00006c  0609              LSLS     r1,r1,#24
00006e  4008              ANDS     r0,r0,r1
000070  0e05              LSRS     r5,r0,#24
;;;398            /* Get UART clock divider number */
;;;399            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
000072  4858              LDR      r0,|L13.468|
000074  6b00              LDR      r0,[r0,#0x30]
000076  0700              LSLS     r0,r0,#28
000078  0f00              LSRS     r0,r0,#28
00007a  9008              STR      r0,[sp,#0x20]
00007c  e052              B        |L13.292|
                  |L13.126|
;;;400        }
;;;401        else if (uart == (UART_T *)UART3)
00007e  4858              LDR      r0,|L13.480|
000080  4284              CMP      r4,r0
000082  d10c              BNE      |L13.158|
;;;402        {
;;;403            /* Get UART clock source selection */
;;;404            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART3SEL_Msk) >> CLK_CLKSEL3_UART3SEL_Pos;
000084  4853              LDR      r0,|L13.468|
000086  69c0              LDR      r0,[r0,#0x1c]
000088  2107              MOVS     r1,#7
00008a  0709              LSLS     r1,r1,#28
00008c  4008              ANDS     r0,r0,r1
00008e  0f05              LSRS     r5,r0,#28
;;;405            /* Get UART clock divider number */
;;;406            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART3DIV_Msk) >> CLK_CLKDIV4_UART3DIV_Pos;
000090  4850              LDR      r0,|L13.468|
000092  6b00              LDR      r0,[r0,#0x30]
000094  21f0              MOVS     r1,#0xf0
000096  4008              ANDS     r0,r0,r1
000098  0900              LSRS     r0,r0,#4
00009a  9008              STR      r0,[sp,#0x20]
00009c  e042              B        |L13.292|
                  |L13.158|
;;;407        }
;;;408        else if (uart == (UART_T *)UART4)
00009e  4851              LDR      r0,|L13.484|
0000a0  4284              CMP      r4,r0
0000a2  d10d              BNE      |L13.192|
;;;409        {
;;;410            /* Get UART clock source selection */
;;;411            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART4SEL_Msk) >> CLK_CLKSEL3_UART4SEL_Pos;
0000a4  484b              LDR      r0,|L13.468|
0000a6  69c0              LDR      r0,[r0,#0x1c]
0000a8  2107              MOVS     r1,#7
0000aa  0409              LSLS     r1,r1,#16
0000ac  4008              ANDS     r0,r0,r1
0000ae  0c05              LSRS     r5,r0,#16
;;;412            /* Get UART clock divider number */
;;;413            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART4DIV_Msk) >> CLK_CLKDIV4_UART4DIV_Pos;
0000b0  4848              LDR      r0,|L13.468|
0000b2  6b00              LDR      r0,[r0,#0x30]
0000b4  210f              MOVS     r1,#0xf
0000b6  0209              LSLS     r1,r1,#8
0000b8  4008              ANDS     r0,r0,r1
0000ba  0a00              LSRS     r0,r0,#8
0000bc  9008              STR      r0,[sp,#0x20]
0000be  e031              B        |L13.292|
                  |L13.192|
;;;414        }
;;;415        else if (uart == (UART_T *)UART5)
0000c0  4849              LDR      r0,|L13.488|
0000c2  4284              CMP      r4,r0
0000c4  d10d              BNE      |L13.226|
;;;416        {
;;;417            /* Get UART clock source selection */
;;;418            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART5SEL_Msk) >> CLK_CLKSEL3_UART5SEL_Pos;
0000c6  4843              LDR      r0,|L13.468|
0000c8  69c0              LDR      r0,[r0,#0x1c]
0000ca  2107              MOVS     r1,#7
0000cc  0509              LSLS     r1,r1,#20
0000ce  4008              ANDS     r0,r0,r1
0000d0  0d05              LSRS     r5,r0,#20
;;;419            /* Get UART clock divider number */
;;;420            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART5DIV_Msk) >> CLK_CLKDIV4_UART5DIV_Pos;
0000d2  4840              LDR      r0,|L13.468|
0000d4  6b00              LDR      r0,[r0,#0x30]
0000d6  210f              MOVS     r1,#0xf
0000d8  0309              LSLS     r1,r1,#12
0000da  4008              ANDS     r0,r0,r1
0000dc  0b00              LSRS     r0,r0,#12
0000de  9008              STR      r0,[sp,#0x20]
0000e0  e020              B        |L13.292|
                  |L13.226|
;;;421        }
;;;422        else if (uart == (UART_T *)UART6)
0000e2  4842              LDR      r0,|L13.492|
0000e4  4284              CMP      r4,r0
0000e6  d10d              BNE      |L13.260|
;;;423        {
;;;424            /* Get UART clock source selection */
;;;425            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART6SEL_Msk) >> CLK_CLKSEL3_UART6SEL_Pos;
0000e8  483a              LDR      r0,|L13.468|
0000ea  69c0              LDR      r0,[r0,#0x1c]
0000ec  2107              MOVS     r1,#7
0000ee  0209              LSLS     r1,r1,#8
0000f0  4008              ANDS     r0,r0,r1
0000f2  0a05              LSRS     r5,r0,#8
;;;426            /* Get UART clock divider number */
;;;427            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART6DIV_Msk) >> CLK_CLKDIV4_UART6DIV_Pos;
0000f4  4837              LDR      r0,|L13.468|
0000f6  6b00              LDR      r0,[r0,#0x30]
0000f8  210f              MOVS     r1,#0xf
0000fa  0409              LSLS     r1,r1,#16
0000fc  4008              ANDS     r0,r0,r1
0000fe  0c00              LSRS     r0,r0,#16
000100  9008              STR      r0,[sp,#0x20]
000102  e00f              B        |L13.292|
                  |L13.260|
;;;428        }
;;;429        else if (uart == (UART_T *)UART7)
000104  483a              LDR      r0,|L13.496|
000106  4284              CMP      r4,r0
000108  d10c              BNE      |L13.292|
;;;430        {
;;;431            /* Get UART clock source selection */
;;;432            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART7SEL_Msk) >> CLK_CLKSEL3_UART7SEL_Pos;
00010a  4832              LDR      r0,|L13.468|
00010c  69c0              LDR      r0,[r0,#0x1c]
00010e  2107              MOVS     r1,#7
000110  0309              LSLS     r1,r1,#12
000112  4008              ANDS     r0,r0,r1
000114  0b05              LSRS     r5,r0,#12
;;;433            /* Get UART clock divider number */
;;;434            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART7DIV_Msk) >> CLK_CLKDIV4_UART7DIV_Pos;
000116  482f              LDR      r0,|L13.468|
000118  6b00              LDR      r0,[r0,#0x30]
00011a  210f              MOVS     r1,#0xf
00011c  0509              LSLS     r1,r1,#20
00011e  4008              ANDS     r0,r0,r1
000120  0d00              LSRS     r0,r0,#20
000122  9008              STR      r0,[sp,#0x20]
                  |L13.292|
;;;435        }    
;;;436    
;;;437        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;438        if (u32UartClkSrcSel == 1ul)
000124  2d01              CMP      r5,#1
000126  d104              BNE      |L13.306|
;;;439        {
;;;440            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
000128  f7fffffe          BL       CLK_GetPLLClockFreq
00012c  00a9              LSLS     r1,r5,#2
00012e  aa02              ADD      r2,sp,#8
000130  5050              STR      r0,[r2,r1]
                  |L13.306|
;;;441        }
;;;442    
;;;443        /* Get PCLK clock frequency if UART clock source selection is PCLK */
;;;444        if (u32UartClkSrcSel == 4ul)
000132  2d04              CMP      r5,#4
000134  d116              BNE      |L13.356|
;;;445        {
;;;446            if ((uart == (UART_T *)UART0) || (uart == (UART_T *)UART2) || (uart == (UART_T *)UART4) || (uart == (UART_T *)UART6))
000136  4826              LDR      r0,|L13.464|
000138  4284              CMP      r4,r0
00013a  d008              BEQ      |L13.334|
00013c  4827              LDR      r0,|L13.476|
00013e  4284              CMP      r4,r0
000140  d005              BEQ      |L13.334|
000142  4828              LDR      r0,|L13.484|
000144  4284              CMP      r4,r0
000146  d002              BEQ      |L13.334|
000148  4828              LDR      r0,|L13.492|
00014a  4284              CMP      r4,r0
00014c  d105              BNE      |L13.346|
                  |L13.334|
;;;447            {
;;;448                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK0Freq();
00014e  f7fffffe          BL       CLK_GetPCLK0Freq
000152  00a9              LSLS     r1,r5,#2
000154  aa02              ADD      r2,sp,#8
000156  5050              STR      r0,[r2,r1]
000158  e004              B        |L13.356|
                  |L13.346|
;;;449            }
;;;450            else     /* UART Port as UART1, UART3, UART5, UART7*/
;;;451            {
;;;452                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK1Freq();
00015a  f7fffffe          BL       CLK_GetPCLK1Freq
00015e  00a9              LSLS     r1,r5,#2
000160  aa02              ADD      r2,sp,#8
000162  5050              STR      r0,[r2,r1]
                  |L13.356|
;;;453            }
;;;454        }
;;;455    
;;;456    
;;;457        /* Set UART baud rate */
;;;458        if (u32baudrate != 0ul)
000164  2e00              CMP      r6,#0
000166  d028              BEQ      |L13.442|
;;;459        {
;;;460            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate);
000168  00a9              LSLS     r1,r5,#2
00016a  aa02              ADD      r2,sp,#8
00016c  5850              LDR      r0,[r2,r1]
00016e  9908              LDR      r1,[sp,#0x20]
000170  1c49              ADDS     r1,r1,#1
000172  f7fffffe          BL       __aeabi_uidivmod
000176  0871              LSRS     r1,r6,#1
000178  1840              ADDS     r0,r0,r1
00017a  4631              MOV      r1,r6
00017c  9000              STR      r0,[sp,#0]
00017e  f7fffffe          BL       __aeabi_uidivmod
000182  1e80              SUBS     r0,r0,#2
000184  9001              STR      r0,[sp,#4]
;;;461    
;;;462            if (u32Baud_Div > 0xFFFFul)
000186  491b              LDR      r1,|L13.500|
000188  9801              LDR      r0,[sp,#4]
00018a  4288              CMP      r0,r1
00018c  d910              BLS      |L13.432|
;;;463            {
;;;464                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate));
00018e  00a9              LSLS     r1,r5,#2
000190  aa02              ADD      r2,sp,#8
000192  5850              LDR      r0,[r2,r1]
000194  9908              LDR      r1,[sp,#0x20]
000196  1c49              ADDS     r1,r1,#1
000198  f7fffffe          BL       __aeabi_uidivmod
00019c  00f1              LSLS     r1,r6,#3
00019e  1840              ADDS     r0,r0,r1
0001a0  4631              MOV      r1,r6
0001a2  9000              STR      r0,[sp,#0]
0001a4  f7fffffe          BL       __aeabi_uidivmod
0001a8  0900              LSRS     r0,r0,#4
0001aa  1e80              SUBS     r0,r0,#2
0001ac  6260              STR      r0,[r4,#0x24]
0001ae  e004              B        |L13.442|
                  |L13.432|
;;;465            }
;;;466            else
;;;467            {
;;;468                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
0001b0  2103              MOVS     r1,#3
0001b2  0709              LSLS     r1,r1,#28
0001b4  9801              LDR      r0,[sp,#4]
0001b6  4308              ORRS     r0,r0,r1
0001b8  6260              STR      r0,[r4,#0x24]
                  |L13.442|
;;;469            }
;;;470        }
;;;471    
;;;472        /* Set UART line configuration */
;;;473        uart->LINE = u32data_width | u32parity | u32stop_bits;
0001ba  4638              MOV      r0,r7
0001bc  990c              LDR      r1,[sp,#0x30]
0001be  4308              ORRS     r0,r0,r1
0001c0  9912              LDR      r1,[sp,#0x48]
0001c2  4308              ORRS     r0,r0,r1
0001c4  60e0              STR      r0,[r4,#0xc]
;;;474    }
0001c6  b00d              ADD      sp,sp,#0x34
0001c8  bdf0              POP      {r4-r7,pc}
;;;475    
                          ENDP

0001ca  0000              DCW      0x0000
                  |L13.460|
                          DCD      ||.constdata||+0x18
                  |L13.464|
                          DCD      0x40070000
                  |L13.468|
                          DCD      0x40000200
                  |L13.472|
                          DCD      0x40071000
                  |L13.476|
                          DCD      0x40072000
                  |L13.480|
                          DCD      0x40073000
                  |L13.484|
                          DCD      0x40074000
                  |L13.488|
                          DCD      0x40075000
                  |L13.492|
                          DCD      0x40076000
                  |L13.496|
                          DCD      0x40077000
                  |L13.500|
                          DCD      0x0000ffff

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;486     */
;;;487    void UART_SetTimeoutCnt(UART_T *uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;488    {
;;;489        /* Set time-out interrupt comparator */
;;;490        uart->TOUT = (uart->TOUT & ~UART_TOUT_TOIC_Msk) | (u32TOC);
000002  0a12              LSRS     r2,r2,#8
000004  0212              LSLS     r2,r2,#8
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;491    
;;;492        /* Set time-out counter enable */
;;;493        uart->INTEN |= UART_INTEN_TOCNTEN_Msk;
00000a  6842              LDR      r2,[r0,#4]
00000c  2301              MOVS     r3,#1
00000e  02db              LSLS     r3,r3,#11
000010  431a              ORRS     r2,r2,r3
000012  6042              STR      r2,[r0,#4]
;;;494    }
000014  4770              BX       lr
;;;495    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;661     */
;;;662    uint32_t UART_Write(UART_T *uart, uint8_t pu8TxBuf[], uint32_t u32WriteBytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;663    {
000002  4603              MOV      r3,r0
;;;664        uint32_t  u32Count, u32delayno;
;;;665        uint32_t  u32Exit = 0ul;
000004  2500              MOVS     r5,#0
;;;666    
;;;667        for (u32Count = 0ul; u32Count != u32WriteBytes; u32Count++)
000006  2000              MOVS     r0,#0
000008  e015              B        |L15.54|
                  |L15.10|
;;;668        {
;;;669            u32delayno = 0ul;
00000a  2400              MOVS     r4,#0
;;;670    
;;;671            while (uart->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)   /* Check Tx Full */
00000c  e006              B        |L15.28|
                  |L15.14|
;;;672            {
;;;673                u32delayno++;
00000e  1c64              ADDS     r4,r4,#1
;;;674    
;;;675                if (u32delayno >= 0x40000000ul)
000010  2601              MOVS     r6,#1
000012  07b6              LSLS     r6,r6,#30
000014  42b4              CMP      r4,r6
000016  d301              BCC      |L15.28|
;;;676                {
;;;677                    u32Exit = 1ul;
000018  2501              MOVS     r5,#1
;;;678                    break;
00001a  e005              B        |L15.40|
                  |L15.28|
00001c  699e              LDR      r6,[r3,#0x18]         ;671
00001e  2701              MOVS     r7,#1                 ;671
000020  05ff              LSLS     r7,r7,#23             ;671
000022  403e              ANDS     r6,r6,r7              ;671
000024  2e00              CMP      r6,#0                 ;671
000026  d1f2              BNE      |L15.14|
                  |L15.40|
000028  bf00              NOP      
;;;679                }
;;;680            }
;;;681    
;;;682            if (u32Exit == 1ul)
00002a  2d01              CMP      r5,#1
00002c  d100              BNE      |L15.48|
;;;683            {
;;;684                break;
00002e  e004              B        |L15.58|
                  |L15.48|
;;;685            }
;;;686            else
;;;687            {
;;;688                uart->DAT = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
000030  5c0e              LDRB     r6,[r1,r0]
000032  601e              STR      r6,[r3,#0]
000034  1c40              ADDS     r0,r0,#1              ;667
                  |L15.54|
000036  4290              CMP      r0,r2                 ;667
000038  d1e7              BNE      |L15.10|
                  |L15.58|
00003a  bf00              NOP                            ;684
;;;689            }
;;;690        }
;;;691    
;;;692        return u32Count;
;;;693    
;;;694    }
00003c  bdf0              POP      {r4-r7,pc}
;;;695    /**
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x01e84800
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x02dc6c00
                          DCD      0x00000000
                          DCD      0x00009600
                          DCD      0x01e84800
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x02dc6c00
                          DCD      0x00000000
                          DCD      0x00009600
                          DCD      0x01e84800
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x02dc6c00
                          DCD      0x00000000
                          DCD      0x00009600

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 402
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
